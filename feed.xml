<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<link href="https://matklad.github.io/feed.xml" rel="self" type="application/atom+xml"/>
<link href="https://matklad.github.io" rel="alternate" type="text/html"/>
<updated>2023-09-27T14:17:57.195Z</updated>
<id>https://matklad.github.io/feed.xml</id>
<title type="html">matklad</title>
<subtitle>Yet another programming blog by Alex Kladov aka matklad.</subtitle>
<author><name>Alex Kladov</name></author>

<entry>
<title type="text">Comparative Analysis</title>
<link href="https://matklad.github.io/2023/09/13/comparative-analysis.html" rel="alternate" type="text/html" title="Comparative Analysis" />
<published>2023-09-13T00:00:00+00:00</published>
<updated>2023-09-13T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/09/13/comparative-analysis</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[Most languages provide 6 comparison operators:]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/09/13/comparative-analysis.html"><![CDATA[
    <h1>
    <a href="#Comparative-Analysis"><span>Comparative Analysis</span> <time datetime="2023-09-13">Sep 13, 2023</time></a>
    </h1>
<p><span>Most languages provide 6 comparison operators:</span></p>

<figure class="code-block">


<pre><code><span class="line">&lt;</span>
<span class="line">&lt;=</span>
<span class="line">&gt;</span>
<span class="line">&gt;=</span>
<span class="line">=</span>
<span class="line">!=</span></code></pre>

</figure>
<p><span>That</span>&rsquo;<span>s too damn many of them! Some time ago I</span>&rsquo;<span>ve noticed that my code involving comparisons is often</span>
<span>hard to understand, and hides bugs. I</span>&rsquo;<span>ve figured some rules of thumb to reduce complexity, which I</span>
<span>want to share.</span></p>
<p><span>The core idea is to canonicalize things. Both </span><code>x &lt; y</code><span> and </span><code>y &gt; x</code><span> mean the same, and, if you use</span>
<span>them with roughly equal frequency, you need to spend extra mental capacity to fold the two versions</span>
<span>into the single </span>&ldquo;<span>x tiny, y HUGE</span>&rdquo;<span> concept in your head.</span></p>
<p><span>The </span><a href="https://en.wikipedia.org/wiki/Number_line"><span>number line</span></a><span> is a great intuition and visualization</span>
<span>for comparisons. If you order things from small to big,</span>
<span class="display"><code>A B C D</code><span>,</span></span>
<span>you get intuitive concept of ordering without using comparison operators. You also plug into your</span>
<span>existing intuition that the sort function arranges arrays in the ascending order.</span></p>
<p><span>So, as a first order rule-of-thumb:</span>
<span class="display"><strong><span>Strongly prefer </span><code>&lt;</code><span> and </span><code>&lt;=</code><span> over </span><code>&gt;</code><span> and </span><code>&gt;=</code></strong></span>
<span>And, when using comparisons, use number line intuition.</span></p>
<p><span>Some snippets:</span></p>
<p><span>Checking if a point is inside the interval:</span></p>

<figure class="code-block">


<pre><code><span class="line">lo &lt;= x <span class="hl-keyword">and</span> x &lt;= hi</span></code></pre>

</figure>
<p><span>Checking if a point is outside of the interval:</span></p>

<figure class="code-block">


<pre><code><span class="line">x &lt; lo <span class="hl-keyword">or</span> hi &lt; x</span></code></pre>

</figure>
<p><span>Segment </span><code>a</code><span> is inside segment </span><code>b</code><span>:</span></p>

<figure class="code-block">


<pre><code><span class="line">b.start &lt;= a.start <span class="hl-keyword">and</span> a.end &lt;= b.end</span></code></pre>

</figure>
<p><span>Segments </span><code>a</code><span> and </span><code>b</code><span> are disjoint (either </span><code>a</code><span> is to the left of </span><code>b</code><span> or </span><code>a</code><span> is to the right of </span><code>b</code><span>):</span></p>

<figure class="code-block">


<pre><code><span class="line">a.end &lt; b.start <span class="hl-keyword">or</span> b.end &lt; a.start</span></code></pre>

</figure>
<p><span>A particular common case for ordered comparisons is checking that an index is in bounds for an</span>
<span>array. Here, the rule about number line works together with another important rule: </span><span class="display"><strong><span>State</span>
<span>invariants positively</span></strong></span></p>
<p><span>The indexing invariant is spelled as </span><span class="display"><code>index &lt; xs.len()</code><span>,</span></span></p>
<p><span>and you should prefer to see it exactly that way in the source code. Concretely,</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">if</span> (index &gt;= xs.len) {</span>
<span class="line"></span>
<span class="line">}</span></code></pre>

</figure>
<p><span>is hard to get right, because is spells the converse of the invariant, and involves an extra mental</span>
<span>negation (this is subtle </span>&mdash;<span> although there isn</span>&rsquo;<span>t a literal negation operator, you absolutely do</span>
<span>think about this as a negation of the invariant). If possible, the code should be reshaped to</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">if</span> (index &lt; xs.len) {</span>
<span class="line"></span>
<span class="line">} <span class="hl-keyword">else</span> {</span>
<span class="line"></span>
<span class="line">}</span></code></pre>

</figure>
]]></content>
</entry>

<entry>
<title type="text">TypeScript is Surprisingly OK for Compilers</title>
<link href="https://matklad.github.io/2023/08/17/typescript-is-surprisingly-ok-for-compilers.html" rel="alternate" type="text/html" title="TypeScript is Surprisingly OK for Compilers" />
<published>2023-08-17T00:00:00+00:00</published>
<updated>2023-08-17T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/08/17/typescript-is-surprisingly-ok-for-compilers</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[There are two main historical trends when choosing an implementation language for something
compiler-shaped.]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/08/17/typescript-is-surprisingly-ok-for-compilers.html"><![CDATA[
    <h1>
    <a href="#TypeScript-is-Surprisingly-OK-for-Compilers"><span>TypeScript is Surprisingly OK for Compilers</span> <time datetime="2023-08-17">Aug 17, 2023</time></a>
    </h1>
<p><span>There are two main historical trends when choosing an implementation language for something</span>
<span>compiler-shaped.</span></p>
<p><span>For more language-centric tasks, like a formal specification, or a toy hobby language, OCaml makes</span>
<span>most sense. See, for example, </span><a href="https://plzoo.andrej.com"><span>plzoo</span></a><span> or </span><a href="https://github.com/WebAssembly/spec/tree/653938a88c6f40eb886d5980ca315136eb861d03/interpreter"><span>WebAssembly reference</span>
<span>interpreter</span></a><span>.</span></p>
<p><span>For something implementation-centric and production ready, C++ is often chosen: LLVM, clang, v8,</span>
<span>HotSpot are all C++.</span></p>
<p><span>These days, Rust is a great new addition to the landscape. It is influenced most directly by ML and</span>
<span>C++, combines their strengths, and even brings something new of its own to the table, like seamless,</span>
<span>safe multithreading. Still, Rust leans heavily towards production readiness side of the spectrum.</span>
<span>While some aspects of it, like a </span>&ldquo;<span>just works</span>&rdquo;<span> build system, help with prototyping as well, there</span>&rsquo;<span>s</span>
<span>still extra complexity tax due to the necessity to model physical layout of data. The usual advice,</span>
<span>when you start building a compiler in Rust, is to avoid pointers and use indexes. Indexes are great!</span>
<span>In large codebase, they allow greater decoupling (side tables can stay local to relevant modules),</span>
<span>improved performance (an index is  </span><code>u32</code><span> and nudges you towards struct-of-arrays layouts), and more</span>
<span>flexible computation strategies (indexes are easier to serialize or plug into incremental</span>
<span>compilation framework). But they do make programming-in-the-small significantly more annoying, which</span>
<span>is a deal-breaker for hobbyist tinkering.</span></p>
<p><span>But OCaml is crufty! Is there something better? Today, I realized that TypeScript might actually be</span>
<span>OK? It is not really surprising, given how the language works, but it never occured to me to think</span>
<span>about TypeScript as an ML equivalent before.</span></p>
<p><span>So, let</span>&rsquo;<span>s write a tiny-tiny typechecker in TS!</span></p>
<p><span>Of course, we start with </span><a href="https://deno.land"><span>deno</span></a><span>. See </span><a href="https://matklad.github.io/2023/02/12/a-love-letter-to-deno.html"><em><span>A Love Letter to</span>
<span>Deno</span></em></a><span> for more details, but the</span>
<span>TL;DR is that deno provides out-of-the-box experience for TypeScript. This is a pain point for</span>
<span>OCaml, and something that Rust does better than either OCaml or C++. But deno does this better than</span>
<span>Rust! It</span>&rsquo;<span>s just a single binary, it comes with linting and formatting, there</span>&rsquo;<span>s no compilation step,</span>
<span>and there are built-in task runner and watch mode. A dream setup for quick PLT hacks!</span></p>
<p><span>And then there</span>&rsquo;<span>s TypeScript itself, with its sufficiently flexible, yet light-ceremony type system.</span></p>
<p><span>Let</span>&rsquo;<span>s start with defining an AST. As we are hacking, we won</span>&rsquo;<span>t bother with making it an IDE-friendly</span>
<span>concrete syntax tree, or incremental-friendly </span>&ldquo;<span>only store relative offsets</span>&rdquo;<span> tree, and will just tag</span>
<span>AST nodes with locations in file:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">interface</span> <span class="hl-title class_">Location</span> {</span>
<span class="line">  <span class="hl-attr">file</span>: <span class="hl-built_in">string</span>;</span>
<span class="line">  <span class="hl-attr">line</span>: <span class="hl-built_in">number</span>;</span>
<span class="line">  <span class="hl-attr">column</span>: <span class="hl-built_in">number</span>;</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Even here, we already see high-level nature of TypeScript </span>&mdash;<span> string is just a </span><code>string</code><span>, there</span>&rsquo;<span>s no</span>
<span>thinking about </span><code>usize</code><span> vs </span><code>u32</code><span> as numbers are just </span><code>number</code><span>s.</span></p>
<p><span>Usually, an expression is defined as a sum-type. As we want to tag each expression with a location,</span>
<span>that representation would be slightly inconvenient for us, so we split things up a bit:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">interface</span> <span class="hl-title class_">Expr</span> {</span>
<span class="line">    <span class="hl-attr">location</span>: <span class="hl-title class_">Location</span>;</span>
<span class="line">    <span class="hl-attr">kind</span>: <span class="hl-title class_">ExprKind</span>;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">type</span> <span class="hl-title class_">ExprKind</span> = <span class="hl-title class_">ExprBool</span> | <span class="hl-title class_">ExprInt</span> | ... ;</span></code></pre>

</figure>
<p><span>One more thing </span>&mdash;<span> as we are going for something quick, we</span>&rsquo;<span>ll be storing inferred types directly in</span>
<span>the AST nodes. Still, we want to keep raw and type-checked AST separate, so what we are going to do</span>
<span>here is to parametrize the </span><code>Expr</code><span> over associated data it stores. A freshly parsed expression would</span>
<span>use </span><code>void</code><span> as data, and the type checker will set it to </span><code>Type</code><span>. Here</span>&rsquo;<span>s what we get:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">interface</span> <span class="hl-title class_">Expr</span>&lt;T&gt; {</span>
<span class="line">  <span class="hl-attr">location</span>: <span class="hl-title class_">Location</span>;</span>
<span class="line">  <span class="hl-attr">data</span>: T;</span>
<span class="line">  <span class="hl-attr">kind</span>: <span class="hl-title class_">ExprKind</span>&lt;T&gt;;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">type</span> <span class="hl-title class_">ExprKind</span>&lt;T&gt; =</span>
<span class="line">  | <span class="hl-title class_">ExprBool</span>&lt;T&gt;</span>
<span class="line">  | <span class="hl-title class_">ExprInt</span>&lt;T&gt;</span>
<span class="line">  | <span class="hl-title class_">ExprBinary</span>&lt;T&gt;</span>
<span class="line">  | <span class="hl-title class_">ExprControl</span>&lt;T&gt;;</span></code></pre>

</figure>
<p><span>A definition of </span><code>ExprBinary</code><span> could look like this:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">interface</span> <span class="hl-title class_">ExprBinary</span>&lt;T&gt; {</span>
<span class="line">  <span class="hl-attr">op</span>: <span class="hl-title class_">BinaryOp</span>;</span>
<span class="line">  <span class="hl-attr">lhs</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;;</span>
<span class="line">  <span class="hl-attr">rhs</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">enum</span> <span class="hl-title class_">BinaryOp</span> {</span>
<span class="line">  <span class="hl-title class_">Add</span>, <span class="hl-title class_">Sub</span>, <span class="hl-title class_">Mul</span>, <span class="hl-title class_">Div</span>,</span>
<span class="line">  <span class="hl-title class_">Eq</span>, <span class="hl-title class_">Neq</span>,</span>
<span class="line">  <span class="hl-title class_">Lt</span>, <span class="hl-title class_">Gt</span>, <span class="hl-title class_">Le</span>, <span class="hl-title class_">Ge</span>,</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Note how I don</span>&rsquo;<span>t introduce separate types for, e.g, </span><code>AddExpr</code><span> and </span><code>SubExpr</code><span> </span>&mdash;<span> all binary</span>
<span>expressions have the same shape, so one type is enough!</span></p>
<p><span>But we need a tiny adjustment here. Our </span><code>Expr</code><span> kind is defined as a union type. To match a value of</span>
<span>a union type a bit of runtime type information is needed. However, it</span>&rsquo;<span>s one of the core properties</span>
<span>of TypeScript that it doesn</span>&rsquo;<span>t add any runtime behaviors. So, if we want to match on expression kinds</span>
<span>(and we for sure want!), we need to give a helping hand to the compiler and include a bit of RTTI</span>
<span>manually. That would be the </span><code>tag</code><span> field:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">interface</span> <span class="hl-title class_">ExprBinary</span>&lt;T&gt; {</span>
<span class="line hl-line">  <span class="hl-attr">tag</span>: <span class="hl-string">&quot;binary&quot;</span>;</span>
<span class="line">  <span class="hl-attr">op</span>: <span class="hl-title class_">BinaryOp</span>;</span>
<span class="line">  <span class="hl-attr">lhs</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;;</span>
<span class="line">  <span class="hl-attr">rhs</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;;</span>
<span class="line">}</span></code></pre>

</figure>
<p><code>tag: "binary"</code><span> means that the only possible runtime value for </span><code>tag</code><span> is the string </span><code>"binary"</code><span>.</span></p>
<p><span>Similarly to various binary expressions, boolean literal and int literal expressions have </span><em><span>almost</span></em>
<span>identical shape.  Almost, because the payload (</span><code>boolean</code><span> or </span><code>number</code><span>) is different. TypeScript</span>
<span>allows us to neatly abstract this over:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">type</span> <span class="hl-title class_">ExprBool</span>&lt;T&gt; = <span class="hl-title class_">ExprLiteral</span>&lt;T, <span class="hl-built_in">boolean</span>, <span class="hl-string">&quot;bool&quot;</span>&gt;;</span>
<span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">type</span> <span class="hl-title class_">ExprInt</span>&lt;T&gt; = <span class="hl-title class_">ExprLiteral</span>&lt;T, <span class="hl-built_in">number</span>, <span class="hl-string">&quot;int&quot;</span>&gt;;</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">interface</span> <span class="hl-title class_">ExprLiteral</span>&lt;T, V, <span class="hl-title class_">Tag</span>&gt; {</span>
<span class="line">  <span class="hl-attr">tag</span>: <span class="hl-title class_">Tag</span>;</span>
<span class="line">  <span class="hl-attr">value</span>: V;</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Finally, for control-flow expressions we only add </span><code>if</code><span> for now:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">type</span> <span class="hl-title class_">ExprControl</span>&lt;T&gt; = <span class="hl-title class_">ExprIf</span>&lt;T&gt;;</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">interface</span> <span class="hl-title class_">ExprIf</span>&lt;T&gt; {</span>
<span class="line">  <span class="hl-attr">tag</span>: <span class="hl-string">&quot;if&quot;</span>;</span>
<span class="line">  <span class="hl-attr">cond</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;;</span>
<span class="line">  <span class="hl-attr">then_branch</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;;</span>
<span class="line">  <span class="hl-attr">else_branch</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;;</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>This concludes the definition of the ast! Let</span>&rsquo;<span>s move on to the type inference! Start with types:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">type</span> <span class="hl-title class_">Type</span> = <span class="hl-title class_">TypeBool</span> | <span class="hl-title class_">TypeInt</span>;</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">interface</span> <span class="hl-title class_">TypeBool</span> {</span>
<span class="line">  <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Bool&quot;</span>;</span>
<span class="line">}</span>
<span class="line"><span class="hl-keyword">const</span> <span class="hl-title class_">TypeBool</span>: <span class="hl-title class_">TypeBool</span> = { <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Bool&quot;</span> };</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">interface</span> <span class="hl-title class_">TypeInt</span> {</span>
<span class="line">  <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Int&quot;</span>;</span>
<span class="line">}</span>
<span class="line"><span class="hl-keyword">const</span> <span class="hl-title class_">TypeInt</span>: <span class="hl-title class_">TypeInt</span> = { <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Int&quot;</span> };</span></code></pre>

</figure>
<p><span>Our types are really simple, we could have gone with </span><span class="display"><code>type Type = "Int" | "Bool"</code><span>,</span></span><span> but</span>
<span>lets do this a bit more enterprisy! We define separate types for integer and boolean types. As these</span>
<span>types are singletons, we also provide canonical definitions. And here is another TypeScript-ism.</span>
<span>Because TypeScript fully erases types, everything related to types lives in a separate namespace. So</span>
<span>you can have a type and a value sharing the same name. Which is exactly what we use to define the</span>
<span>singletons!</span></p>
<p><span>Finally, we can take advantage of our associated-data parametrized expression and write the</span>
<span>signature of</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">infer_types</span>(<span class="hl-params">expr: ast.Expr&lt;<span class="hl-built_in">void</span>&gt;</span>): ast.<span class="hl-property">Expr</span>&lt;<span class="hl-title class_">Type</span>&gt;</span></code></pre>

</figure>
<p><span>As it says on the tin, </span><code>inter_types</code><span> fills in </span><code>Type</code><span> information into the void! Let</span>&rsquo;<span>s fill in the</span>
<span>details!</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">infer_types</span>(<span class="hl-params">expr: ast.Expr&lt;<span class="hl-built_in">void</span>&gt;</span>): ast.<span class="hl-property">Expr</span>&lt;<span class="hl-title class_">Type</span>&gt; {</span>
<span class="line">  <span class="hl-keyword">switch</span> (expr.<span class="hl-property">kind</span>.<span class="hl-property">tag</span>) {</span>
<span class="line">    cas</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>If at this point we hit Enter, the editor completes:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">infer_types</span>(<span class="hl-params">expr: ast.Expr&lt;<span class="hl-built_in">void</span>&gt;</span>): ast.<span class="hl-property">Expr</span>&lt;<span class="hl-title class_">Type</span>&gt; {</span>
<span class="line">  <span class="hl-keyword">switch</span> (expr.<span class="hl-property">kind</span>.<span class="hl-property">tag</span>) {</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;bool&quot;</span>:</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;int&quot;</span>:</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;binary&quot;</span>:</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;if&quot;</span>:</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>There</span>&rsquo;<span>s one problem though. What we really want to write here is something like</span>
<span class="display"><code>const inferred_type = switch(..)</code><span>,</span></span>
<span>but in TypeScript </span><code>switch</code><span> is a statement, not an expression.</span>
<span>So let</span>&rsquo;<span>s define a generic visitor!</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">type</span> <span class="hl-title class_">Visitor</span>&lt;T, R&gt; = {</span>
<span class="line">  <span class="hl-title function_">bool</span>(<span class="hl-attr">kind</span>: <span class="hl-title class_">ExprBool</span>&lt;T&gt;): R;</span>
<span class="line">  <span class="hl-title function_">int</span>(<span class="hl-attr">kind</span>: <span class="hl-title class_">ExprInt</span>&lt;T&gt;): R;</span>
<span class="line">  <span class="hl-title function_">binary</span>(<span class="hl-attr">kind</span>: <span class="hl-title class_">ExprBinary</span>&lt;T&gt;): R;</span>
<span class="line">  <span class="hl-keyword">if</span>(<span class="hl-attr">kind</span>: <span class="hl-title class_">ExprIf</span>&lt;T&gt;): R;</span>
<span class="line">};</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">function</span> visit&lt;T, R&gt;(</span>
<span class="line">  <span class="hl-attr">expr</span>: <span class="hl-title class_">Expr</span>&lt;T&gt;,</span>
<span class="line">  <span class="hl-attr">v</span>: <span class="hl-title class_">Visitor</span>&lt;T, R&gt;,</span>
<span class="line">): R {</span>
<span class="line">  <span class="hl-keyword">switch</span> (expr.<span class="hl-property">kind</span>.<span class="hl-property">tag</span>) {</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;bool&quot;</span>: <span class="hl-keyword">return</span> v.<span class="hl-title function_">bool</span>(expr.<span class="hl-property">kind</span>);</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;int&quot;</span>: <span class="hl-keyword">return</span> v.<span class="hl-title function_">int</span>(expr.<span class="hl-property">kind</span>);</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;binary&quot;</span>: <span class="hl-keyword">return</span> v.<span class="hl-title function_">binary</span>(expr.<span class="hl-property">kind</span>);</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;if&quot;</span>: <span class="hl-keyword">return</span> v.<span class="hl-title function_">if</span>(expr.<span class="hl-property">kind</span>);</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Armed with the </span><code>visit</code><span>, we can ergonomically match over the expression:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">infer_types</span>(<span class="hl-params">expr: ast.Expr&lt;<span class="hl-built_in">void</span>&gt;</span>): ast.<span class="hl-property">Expr</span>&lt;<span class="hl-title class_">Type</span>&gt; {</span>
<span class="line">  <span class="hl-keyword">const</span> ty = <span class="hl-title function_">visit</span>(expr, {</span>
<span class="line">    <span class="hl-attr">bool</span>: <span class="hl-function">() =&gt;</span> <span class="hl-title class_">TypeBool</span>,</span>
<span class="line">    <span class="hl-attr">int</span>: <span class="hl-function">() =&gt;</span> <span class="hl-title class_">TypeInt</span>,</span>
<span class="line">    <span class="hl-attr">binary</span>: <span class="hl-function">(<span class="hl-params">kind: ast.ExprBinary&lt;<span class="hl-built_in">void</span>&gt;</span>) =&gt;</span> <span class="hl-title function_">result_type</span>(kind.<span class="hl-property">op</span>),</span>
<span class="line">    <span class="hl-attr">if</span>: (<span class="hl-attr">kind</span>: ast.<span class="hl-property">ExprIf</span>&lt;<span class="hl-built_in">void</span>&gt;) {</span>
<span class="line">      ...</span>
<span class="line">    },</span>
<span class="line">  });</span>
<span class="line">  ...</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">result_type</span>(<span class="hl-params">op: ast.BinaryOp</span>): <span class="hl-title class_">Type</span> {</span>
<span class="line">  <span class="hl-keyword">switch</span> (op) { <span class="hl-comment">// A tad verbose, but auto-completed!</span></span>
<span class="line">    <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Add</span>: <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Sub</span>:</span>
<span class="line">    <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Mul</span>: <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Div</span>:</span>
<span class="line">      <span class="hl-keyword">return</span> <span class="hl-title class_">TypeInt</span></span>
<span class="line"></span>
<span class="line">    <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Eq</span>: <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Neq</span>:</span>
<span class="line">      <span class="hl-keyword">return</span> <span class="hl-title class_">TypeBool</span></span>
<span class="line"></span>
<span class="line">    <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Lt</span>: <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Gt</span>:</span>
<span class="line">    <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Le</span>: <span class="hl-keyword">case</span> ast.<span class="hl-property">BinaryOp</span>.<span class="hl-property">Ge</span>:</span>
<span class="line">      <span class="hl-keyword">return</span> <span class="hl-title class_">TypeBool</span></span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Before we go further, let</span>&rsquo;<span>s generalize this visiting pattern a bit! Recall that our expressions are</span>
<span>parametrized by the type of associated data, and type-checker-shaped transformations are essentially an</span>
<code class="display">Expr&lt;U&gt; -&gt; Expr&lt;V&gt;</code>
<span>transformation.</span></p>
<p><span>Let</span>&rsquo;<span>s make this generic!</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">function</span> transform&lt;U, V&gt;(<span class="hl-attr">expr</span>: <span class="hl-title class_">Expr</span>&lt;U&gt;, <span class="hl-attr">v</span>: <span class="hl-title class_">Visitor</span>&lt;V, V&gt;): <span class="hl-title class_">Expr</span>&lt;V&gt; {</span></code></pre>

</figure>
<p><span>Transform maps an expression carrying </span><code>T</code><span> into an expression carrying </span><code>V</code><span> by applying an </span><code>f</code>
<span>visitor. Importantly, it</span>&rsquo;<span>s </span><code>Visitor&lt;V, V&gt;</code><span>, rather than a </span><code>Visitor&lt;U, V&gt;</code><span>. This is</span>
<span>counter-intuitive, but correct </span>&mdash;<span> we run transformation bottom up, transforming the leaves first.</span>
<span>So, when the time comes to visit an interior node, all subexpression will have been transformed!</span></p>
<p><span>The body of </span><code>transform</code><span> is wordy, but regular, rectangular, and auto-completes itself:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">export</span> <span class="hl-keyword">function</span> transform&lt;U, V&gt;(<span class="hl-attr">expr</span>: <span class="hl-title class_">Expr</span>&lt;U&gt;, <span class="hl-attr">v</span>: <span class="hl-title class_">Visitor</span>&lt;V, V&gt;): <span class="hl-title class_">Expr</span>&lt;V&gt; {</span>
<span class="line">  <span class="hl-keyword">switch</span> (expr.<span class="hl-property">kind</span>.<span class="hl-property">tag</span>) {</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;bool&quot;</span>:</span>
<span class="line">      <span class="hl-keyword">return</span> {</span>
<span class="line">        <span class="hl-attr">location</span>: expr.<span class="hl-property">location</span>,</span>
<span class="line">        <span class="hl-attr">data</span>: v.<span class="hl-title function_">bool</span>(expr.<span class="hl-property">kind</span>),</span>
<span class="line">        <span class="hl-attr">kind</span>: expr.<span class="hl-property">kind</span>, <i class="callout" data-value="1"></i></span>
<span class="line">      };</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;int&quot;</span>:</span>
<span class="line">      <span class="hl-keyword">return</span> {</span>
<span class="line">        <span class="hl-attr">location</span>: expr.<span class="hl-property">location</span>,</span>
<span class="line">        <span class="hl-attr">data</span>: v.<span class="hl-title function_">int</span>(expr.<span class="hl-property">kind</span>),</span>
<span class="line">        <span class="hl-attr">kind</span>: expr.<span class="hl-property">kind</span>,</span>
<span class="line">      };</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;binary&quot;</span>: {</span>
<span class="line">      <span class="hl-keyword">const</span> <span class="hl-attr">kind</span>: <span class="hl-title class_">ExprBinary</span>&lt;V&gt; = { <i class="callout" data-value="2"></i></span>
<span class="line">        <span class="hl-attr">tag</span>: <span class="hl-string">&quot;binary&quot;</span>,</span>
<span class="line">        <span class="hl-attr">op</span>: expr.<span class="hl-property">kind</span>.<span class="hl-property">op</span>,</span>
<span class="line">        <span class="hl-attr">lhs</span>: <span class="hl-title function_">transform</span>(expr.<span class="hl-property">kind</span>.<span class="hl-property">lhs</span>, v),</span>
<span class="line">        <span class="hl-attr">rhs</span>: <span class="hl-title function_">transform</span>(expr.<span class="hl-property">kind</span>.<span class="hl-property">rhs</span>, v),</span>
<span class="line">      };</span>
<span class="line">      <span class="hl-keyword">return</span> {</span>
<span class="line">        <span class="hl-attr">location</span>: expr.<span class="hl-property">location</span>,</span>
<span class="line">        <span class="hl-attr">data</span>: v.<span class="hl-title function_">binary</span>(kind), <i class="callout" data-value="2"></i></span>
<span class="line">        <span class="hl-attr">kind</span>: kind,</span>
<span class="line">      };</span>
<span class="line">    }</span>
<span class="line">    <span class="hl-keyword">case</span> <span class="hl-string">&quot;if&quot;</span>: {</span>
<span class="line">      <span class="hl-keyword">const</span> <span class="hl-attr">kind</span>: <span class="hl-title class_">ExprIf</span>&lt;V&gt; = {</span>
<span class="line">        <span class="hl-attr">tag</span>: <span class="hl-string">&quot;if&quot;</span>,</span>
<span class="line">        <span class="hl-attr">cond</span>: <span class="hl-title function_">transform</span>(expr.<span class="hl-property">kind</span>.<span class="hl-property">cond</span>, v),</span>
<span class="line">        <span class="hl-attr">then_branch</span>: <span class="hl-title function_">transform</span>(expr.<span class="hl-property">kind</span>.<span class="hl-property">then_branch</span>, v),</span>
<span class="line">        <span class="hl-attr">else_branch</span>: <span class="hl-title function_">transform</span>(expr.<span class="hl-property">kind</span>.<span class="hl-property">else_branch</span>, v),</span>
<span class="line">      };</span>
<span class="line">      <span class="hl-keyword">return</span> {</span>
<span class="line">        <span class="hl-attr">location</span>: expr.<span class="hl-property">location</span>,</span>
<span class="line">        <span class="hl-attr">data</span>: v.<span class="hl-title function_">if</span>(kind),</span>
<span class="line">        <span class="hl-attr">kind</span>: kind,</span>
<span class="line">      };</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<p><span>Note how here </span><code>expr.kind</code><span> is both </span><code>Expr&lt;U&gt;</code><span> and  </span><code>Expr&lt;V&gt;</code><span> </span>&mdash;<span> literals don</span>&rsquo;<span>t depend on this type</span>
<span>parameter, and TypeScript is smart enough to figure this out without us manually re-assembling</span>
<span>the same value with a different type.</span></p>
</li>
<li>
<p><span>This is where that magic with </span><code>Visitor&lt;V, V&gt;</code><span> happens.</span></p>
</li>
</ol>
<p><span>The code is pretty regular here though! So at this point we might actually recall that TypeScript is</span>
<span>a dynamically-typed language, and write a generic traversal using </span><code>Object.keys</code><span>, </span><em><span>while keeping the</span>
<span>static function signature in-place</span></em><span>. I don</span>&rsquo;<span>t think we need to do it here, but there</span>&rsquo;<span>s comfort in</span>
<span>knowing that it</span>&rsquo;<span>s possible!</span></p>
<p><em><span>Now</span></em><span> implementing type inference should be a breeze! We need some way to emit type errors though.</span>
<span>With TypeScript, it would be trivial to accumulate errors into an array as a side-effect, but let</span>&rsquo;<span>s</span>
<span>actually represent type errors as instances of a specific type, </span><code>TypeError</code><span> (pun intended):</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">type</span> <span class="hl-title class_">Type</span> = <span class="hl-title class_">TypeBool</span> | <span class="hl-title class_">TypeInt</span> | <span class="hl-title class_">TypeError</span>;</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">interface</span> <span class="hl-title class_">TypeError</span> {</span>
<span class="line">  <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Error&quot;</span>;</span>
<span class="line">  <span class="hl-attr">location</span>: ast.<span class="hl-property">Location</span>;</span>
<span class="line">  <span class="hl-attr">message</span>: <span class="hl-built_in">string</span>;</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>To check ifs and binary expressions, we would also need a utility for comparing types:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">type_equal</span>(<span class="hl-params">lhs: Type, rhs: Type</span>): <span class="hl-built_in">boolean</span> {</span>
<span class="line">  <span class="hl-keyword">if</span> (lhs.<span class="hl-property">tag</span> == <span class="hl-string">&quot;Error&quot;</span> || rhs.<span class="hl-property">tag</span> == <span class="hl-string">&quot;Error&quot;</span>) <span class="hl-keyword">return</span> <span class="hl-literal">true</span>;</span>
<span class="line">  <span class="hl-keyword">return</span> lhs.<span class="hl-property">tag</span> == rhs.<span class="hl-property">tag</span>;</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>We make the </span><code>Error</code><span> type equal to any other type to prevent cascading failures. With all that</span>
<span>machinery in place, our type checker is finally:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">infer_types</span>(<span class="hl-params">expr: ast.Expr&lt;<span class="hl-built_in">void</span>&gt;</span>): ast.<span class="hl-property">Expr</span>&lt;<span class="hl-title class_">Type</span>&gt; {</span>
<span class="line">  <span class="hl-keyword">return</span> ast.<span class="hl-title function_">transform</span>(expr, {</span>
<span class="line">    <span class="hl-attr">bool</span>: (): <span class="hl-function"><span class="hl-params">Type</span> =&gt;</span> <span class="hl-title class_">TypeBool</span>,</span>
<span class="line">    <span class="hl-attr">int</span>: (): <span class="hl-function"><span class="hl-params">Type</span> =&gt;</span> <span class="hl-title class_">TypeInt</span>,</span>
<span class="line"></span>
<span class="line">    <span class="hl-attr">binary</span>: (<span class="hl-attr">kind</span>: ast.<span class="hl-property">ExprBinary</span>&lt;<span class="hl-title class_">Type</span>&gt;, <span class="hl-attr">location</span>: ast.<span class="hl-property">Location</span>): <span class="hl-function"><span class="hl-params">Type</span> =&gt;</span> {</span>
<span class="line">      <span class="hl-keyword">if</span> (!<span class="hl-title function_">type_equal</span>(kind.<span class="hl-property">lhs</span>.<span class="hl-property">data</span>, kind.<span class="hl-property">rhs</span>.<span class="hl-property">data</span>)) {</span>
<span class="line">        <span class="hl-keyword">return</span> {</span>
<span class="line">          <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Error&quot;</span>,</span>
<span class="line">          location,</span>
<span class="line">          <span class="hl-attr">message</span>: <span class="hl-string">&quot;binary expression operands have different types&quot;</span>,</span>
<span class="line">        };</span>
<span class="line">      }</span>
<span class="line">      <span class="hl-keyword">return</span> <span class="hl-title function_">result_type</span>(kind.<span class="hl-property">op</span>);</span>
<span class="line">    },</span>
<span class="line"></span>
<span class="line">    <span class="hl-attr">if</span>: (<span class="hl-attr">kind</span>: ast.<span class="hl-property">ExprIf</span>&lt;<span class="hl-title class_">Type</span>&gt;, <span class="hl-attr">location</span>: ast.<span class="hl-property">Location</span>): <span class="hl-function"><span class="hl-params">Type</span> =&gt;</span> {</span>
<span class="line">      <span class="hl-keyword">if</span> (!<span class="hl-title function_">type_equal</span>(kind.<span class="hl-property">cond</span>.<span class="hl-property">data</span>, <span class="hl-title class_">TypeBool</span>)) {</span>
<span class="line">        <span class="hl-keyword">return</span> {</span>
<span class="line">          <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Error&quot;</span>,</span>
<span class="line">          location,</span>
<span class="line">          <span class="hl-attr">message</span>: <span class="hl-string">&quot;if condition is not a boolean&quot;</span>,</span>
<span class="line">        };</span>
<span class="line">      }</span>
<span class="line">      <span class="hl-keyword">if</span> (!<span class="hl-title function_">type_equal</span>(kind.<span class="hl-property">then_branch</span>.<span class="hl-property">data</span>, kind.<span class="hl-property">else_branch</span>.<span class="hl-property">data</span>)) {</span>
<span class="line">        <span class="hl-keyword">return</span> {</span>
<span class="line">          <span class="hl-attr">tag</span>: <span class="hl-string">&quot;Error&quot;</span>,</span>
<span class="line">          location,</span>
<span class="line">          <span class="hl-attr">message</span>: <span class="hl-string">&quot;if branches have different types&quot;</span>,</span>
<span class="line">        };</span>
<span class="line">      }</span>
<span class="line">      <span class="hl-keyword">return</span> kind.<span class="hl-property">then_branch</span>.<span class="hl-property">data</span>;</span>
<span class="line">    },</span>
<span class="line">  });</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">result_type</span>(<span class="hl-params">op: ast.BinaryOp</span>): <span class="hl-title class_">Type</span> {</span>
<span class="line">    ...</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Astute reader will notice that our visitor functions now take an extra </span><code>ast.Location</code><span> argument.</span>
<span>TypeScript allows using this argument only in cases where it is needed, cutting down verbosity.</span></p>
<p><span>And that</span>&rsquo;<span>s all for today! The end result is pretty neat and concise. It took some typing to get there,</span>
<span>but TypeScript autocompletion really helps with that! What</span>&rsquo;<span>s more important, there was very little</span>
<span>fighting with the language, and the result feels quite natural and directly corresponds to the shape</span>
<span>of the problem.</span></p>
<p><span>I am not entirely sure in the conclusion just yet, but I think I</span>&rsquo;<span>ll be using TypeScript as my tool</span>
<span>of choice for various small language hacks. It is surprisingly productive due to the confluence of</span>
<span>three aspects:</span></p>
<ul>
<li>
<span>deno is a perfect scripting runtime! Small, hermetic, powerful, and optimized for effective</span>
<span>development workflows.</span>
</li>
<li>
<span>TypeScript tooling is great </span>&mdash;<span> the IDE is helpful and productive (and deno makes sure that it</span>
<span>also requires zero configuration)</span>
</li>
<li>
<span>The language is powerful both at runtime and at compile time. You can get pretty fancy with types,</span>
<span>but you can also just escape to dynamic world if you need some very high-order code.</span>
</li>
</ul>
<hr>
<p><span>Just kidding, here</span>&rsquo;<span>s one more cute thing. Let</span>&rsquo;<span>s say that we want to have lots of syntactic sugar,</span>
<span>and also want type-safe desugaring. We could tweak our setup a bit for that: instead of </span><code>Expr</code><span> and</span>
<code>ExprKind</code><span> being parametrized over associated data, we circularly parametrize </span><code>Expr</code><span> by the whole</span>
<code>ExprKind</code><span> and  vice verse:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">interface</span> <span class="hl-title class_">Expr</span>&lt;K&gt; {</span>
<span class="line">  <span class="hl-attr">location</span>: <span class="hl-title class_">Location</span>,</span>
<span class="line">  <span class="hl-attr">kind</span>: K,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">interface</span> <span class="hl-title class_">ExprBinary</span>&lt;E&gt; {</span>
<span class="line">  <span class="hl-attr">op</span>: <span class="hl-title class_">BinaryOp</span>,</span>
<span class="line">  <span class="hl-attr">lhs</span>: E,</span>
<span class="line">  <span class="hl-attr">rhs</span>: E,</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>This allows expressing desugaring in a type-safe manner!</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// Fundamental, primitive expressions.</span></span>
<span class="line"><span class="hl-keyword">type</span> <span class="hl-title class_">ExprKindCore</span>&lt;E&gt; =</span>
<span class="line">    <span class="hl-title class_">ExprInt</span>&lt;E&gt; | <span class="hl-title class_">ExprBinary</span>&lt;E&gt; | <span class="hl-title class_">ExprIf</span>&lt;E&gt;</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Expressions which are either themselves primitive,</span></span>
<span class="line"><span class="hl-comment">// or can be desugared to primitives.</span></span>
<span class="line"><span class="hl-keyword">type</span> <span class="hl-title class_">ExprKindSugar</span>&lt;E&gt; = <span class="hl-title class_">ExprKindCore</span>&lt;E&gt;</span>
<span class="line">    | <span class="hl-title class_">ExprCond</span>&lt;E&gt; | <span class="hl-title class_">ExprUnless</span>&lt;E&gt;</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">type</span> <span class="hl-title class_">ExprCore</span> = <span class="hl-title class_">Expr</span>&lt;<span class="hl-title class_">ExprKindCore</span>&lt;<span class="hl-title class_">ExprCore</span>&gt;&gt;;</span>
<span class="line"><span class="hl-keyword">type</span> <span class="hl-title class_">ExprSugar</span> = <span class="hl-title class_">Expr</span>&lt;<span class="hl-title class_">ExprKindSugar</span>&lt;<span class="hl-title class_">ExprSugar</span>&gt;&gt;;</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Desugaring works by reducing the set of expression kinds.</span></span>
<span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">desugar</span>(<span class="hl-params">expr: ExprSugar</span>): <span class="hl-title class_">ExprCore</span></span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// A desugaring steps takes a (potentially sugar) expression,</span></span>
<span class="line"><span class="hl-comment">// whose subexpression are already desugared,</span></span>
<span class="line"><span class="hl-comment">// and produces an equivalent core expression.</span></span>
<span class="line"><span class="hl-keyword">function</span> <span class="hl-title function_">desugar_one</span>(<span class="hl-params"></span></span>
<span class="line"><span class="hl-params">    expr: ExprKindSugar&lt;ExprCore&gt;,</span></span>
<span class="line"><span class="hl-params"></span>): <span class="hl-title class_">ExprKindCore</span>&lt;<span class="hl-title class_">ExprCore</span>&gt;</span></code></pre>

</figure>
]]></content>
</entry>

<entry>
<title type="text">Role Of Algorithms</title>
<link href="https://matklad.github.io/2023/08/13/role-of-algorithms.html" rel="alternate" type="text/html" title="Role Of Algorithms" />
<published>2023-08-13T00:00:00+00:00</published>
<updated>2023-08-13T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/08/13/role-of-algorithms</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[This is lobste.rs comment as an article, so expect even more abysmal editing than usual.]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/08/13/role-of-algorithms.html"><![CDATA[
    <h1>
    <a href="#Role-Of-Algorithms"><span>Role Of Algorithms</span> <time datetime="2023-08-13">Aug 13, 2023</time></a>
    </h1>
<p><span>This is lobste.rs comment as an article, so expect even more abysmal editing than usual.</span></p>
<p><span>Let me expand on something I mentioned in the</span>
<a href="https://matklad.github.io/2023/08/06/fantastic-learning-resources.html" class="display url">https://matklad.github.io/2023/08/06/fantastic-learning-resources.html</a>
<span>post:</span></p>
<p>&ldquo;<span>Algorithms</span>&rdquo;<span> are a useful skill not because you use it at work every day, but because they train you</span>
<span>to be better at particular aspects of software engineering.</span></p>
<p><span>Specifically:</span></p>
<p><em><span>First</span></em><span>, algorithms drill the skill of bug-free coding. Algorithms are hard and frustrating! Subtle</span>
<span>off-by-one might not matter for simple tests, but breaks corner cases. But if you practice</span>
<span>algorithms, you get better at this particular skill of writing correct small programs, and I think</span>
<span>this probably generalizes.</span></p>
<p><span>To give an array of analogies:</span></p>
<ul>
<li>
<p><span>People do cardio or strength exercises not because they need to lift heavy weights in real life.</span>
<span>Quite the opposite </span>&mdash;<span> there</span>&rsquo;<span>s </span><em><span>too little</span></em><span> physical exertion in our usual lives, so we need extra</span>
<span>exercises for our bodies to gain generalized health (which </span><em><span>is</span></em><span> helpful in day-to-day life).</span></p>
</li>
<li>
<p><span>You don</span>&rsquo;<span>t practice complex skill by mere repetition. You first break it down into atomic trainable</span>
<span>sub skills, and drill each sub skill separately in unrealistic condition. Writing correct</span>
<span>algorithmy code is a sub skill of software engineering.</span></p>
</li>
<li>
<p><span>When you optimize system, you don</span>&rsquo;<span>t just repeatedly run end-to-end test until things go fast. You</span>
<span>first identify the problematic area, then write a targeted micro benchmark to isolate this</span>
<span>particular effect, and then you optimize that using much shorter event loop.</span></p>
</li>
</ul>
<p><span>I still remember two specific lessons I learned when I started doing algorithms many years ago:</span></p>
<dl>
<dt><span>Debugging complex code is hard, </span><em><span>first</span></em><span> simplify, </span><em><span>then</span></em><span> debug</span></dt>
<dd>
<p><span>Originally, when I was getting a failed test, I sort of tried to add more code to my program to</span>
<span>make it pass. At some point I realized that this is going nowhere, and then I changed my workflow</span>
<span>to first try to </span><em><span>remove</span></em><span> as much code as I can, and only then investigate the problematic test</span>
<span>case (which with time morphed into a skill of not writing more code then necessary in the first</span>
<span>place).</span></p>
</dd>
<dt><span>Single source of truth is good</span></dt>
<dd>
<p><span>A lot of my early bugs was due to me duplicating the same piece of information in two places and</span>
<span>then getting them out of sync. Internalizing that as a single source of truth fixed the issues.</span></p>
</dd>
</dl>
<p><span>Meta note: if you already know this, my lessons are useless. If you don</span>&rsquo;<span>t yet know them, they are</span>
<em><span>still</span></em><span> useless and most likely will bounce off you. This is tacit knowledge </span>&mdash;<span> it</span>&rsquo;<span>s very hard to</span>
<span>convey it verbally, it is much more efficient to learn these things yourself by doing.</span></p>
<p><span>Somewhat related, I noticed a surprising correlation between programming skills in the small, and</span>
<span>programming skills in the large. You can solve a problem in five lines of code, or, if you try hard,</span>
<span>in ten lines of code. If you consistently come up with concise solutions in the small, chances are</span>
<span>large scale design will be simple as well.</span></p>
<p><span>I don</span>&rsquo;<span>t know how true is that, as I never tried to look at a proper study, but it looks very</span>
<span>plausible from what I</span>&rsquo;<span>ve seen. </span><em><span>If</span></em><span> this is true, the next interesting question is: </span>&ldquo;<span>if you train</span>
<span>programming-in-the-small skills, do they transfer to programming in the large?</span>&rdquo;<span>. Again, I don</span>&rsquo;<span>t</span>
<span>know, but I</span>&rsquo;<span>d take this Pascal</span>&rsquo;<span>s wager.</span></p>
<p><em><span>Second</span></em><span>, algorithms teach about properties and invariants. Some lucky people get those skills from</span>
<span>a hard math background, but algorithms are a much more accessible way to learn them, as everything</span>
<span>is very visual, immediately testable, and has very short and clear feedback loop.</span></p>
<p><span>And properties and invariants is what underlines most big and successful systems. Like 90% of the</span>
<span>code is just fluff and glue, and if you have the skill to see the 10% that is architecturally</span>
<span>salient properties, you could comprehend the system much faster.</span></p>
<p><em><span>Third</span></em><span>, algorithms occasionally </span><em><span>are</span></em><span> useful at the job! Just last week on our design walk&amp;talk we</span>
<span>were brainstorming one particular problem, and I was like</span></p>

<figure class="blockquote">
<blockquote><p><span>Wait, so the problem here is that our solution is O(1) amortized, but really that means O(N)</span>
<span>occasionally and that creates problem. I wonder if we could shift amortized work to when we do the</span>
<span>real work, sort of how there are helper threads in concurrent programming. Ohh, this actually sounds</span>
<span>like range query problem! Yeah, I think that cryptic trick that is called </span>&ldquo;<span>дерево отрезков</span>&rdquo;<span> in</span>
<span>Russian and doesn</span>&rsquo;<span>t have a meme name in English (</span>&ldquo;<span>monoid tree</span>&rdquo;<span> is a good, but unknown, name) could</span>
<span>help here. Yup, that actually does solve amortization issue, this will be O(log N) non-amortized.</span></p>
</blockquote>

</figure>
<p><span>We probably won</span>&rsquo;<span>t go with that solution as that</span>&rsquo;<span>s too complex algorithmically for what ultimately is</span>
<span>a corner case, </span><em><span>but</span></em><span> it</span>&rsquo;<span>s important that we understand problem space in detail before we pick a</span>
<span>solution.</span></p>
<p><span>Note also how algorithms </span><em><span>vocabulary</span></em><span> helps me to think about the problem. In math (including</span>
<span>algorithms), there</span>&rsquo;<span>s just like a handful of ideas which are applied again and again under different</span>
<span>guises. You need some amount of insight of course, but, for most simple problems, what you actually</span>
<span>need is just an ability to recognize the structure you</span>&rsquo;<span>ve seen somewhere already.</span></p>
<p><em><span>Fourth</span></em><span>, connecting to the previous ones, the ideas really do form interconnected web which, on a</span>
<span>deep level, underpins a whole lot of stuff. So, if you do have non-zero amount of pure curiosity</span>
<span>when it comes to learning programming, algorithms cut pretty deep to the foundation. Let me repeat</span>
<span>the list from the last post, but with explicit connections to other things:</span></p>
<dl>
<dt><span>linear search</span></dt>
<dd>
<p><span>assoc lists in most old functional languages work that way</span></p>
</dd>
<dt><span>binary search</span></dt>
<dd>
<p><span>It is literally everywhere. Also, binary search got a cute name, but actually it isn</span>&rsquo;<span>t the</span>
<span>primitive operation. The primitive operation is </span><code>partition_point</code><span>, a predicate version of binary</span>
<span>search. This is what you should add to your language</span>&rsquo;<span>s stdlib as a primitive, and base everything</span>
<span>else in terms of it. Also, it is one of the few cases where we know lower bound of complexity. If</span>
<span>an algorithm does k binary comparisons, it can give at most 2</span><sup><span>k</span></sup><span> distinct answers. So, to find</span>
<span>insertion point among n items, you need at least k questions such that 2</span><sup><span>k</span></sup><span> &gt; n.</span></p>
</dd>
<dt><span>quadratic sorting</span></dt>
<dd>
<p><span>We use it at work! Some collections are statically bound by a small constant, and quadratically</span>
<span>sorting them just needs less machine code. We are also a bit paranoid that production sort</span>
<span>algorithms are very complex and </span><em><span>might</span></em><span> have subtle bugs, esp in newer languages.</span></p>
</dd>
<dt><span>merge sort</span></dt>
<dd>
<p><span>This is how you sort things on disk. This is also how LSM-trees, the most practically important</span>
<span>data structure you haven</span>&rsquo;<span>t learned about in school, works! And k-way merge also is occasionally</span>
<span>useful (this is from work from three weeks ago).</span></p>
</dd>
<dt><span>heap sort</span></dt>
<dd>
<p><span>Well, this one is only actually useful for the heap, </span><em><span>but</span></em><span> I think maybe the kernel uses it when</span>
<span>it needs to sort something in place, without extra memory, and in guaranteed O(N log N)?</span></p>
</dd>
<dt><span>binary heap</span></dt>
<dd>
<p><span>Binary heaps are everywhere! Notably, simple timers are a binary heap of things in the order of</span>
<span>expiration. This is also a part of Dijkstra and k-way-merge.</span></p>
</dd>
<dt><span>growable array</span></dt>
<dd>
<p><span>That</span>&rsquo;<span>s the mostly widely used collection of them all! Did you know that grow factor 2 has a</span>
<span>problem that the size after </span><code>n</code><span> reallocations is larger then the sum total of all previous sizes,</span>
<span>so the allocator can</span>&rsquo;<span>t re-use the space? Anecdotally, growth factors less than two are preferable</span>
<span>for this reason.</span></p>
</dd>
<dt><span>doubly-linked list</span></dt>
<dd>
<p><span>At the heart of rust-analyzer is a </span><a href="https://github.com/rust-analyzer/rowan/blob/87909d03dfe78d07ae932151e105dfde7ae87536/src/sll.rs"><span>two-dimensional doubly-linked</span>
<span>list</span></a><span>.</span></p>
</dd>
<dt><span>binary search tree</span></dt>
<dd>
<p><span>Again, rust-analyzer green tree are binary search trees using offset as an implicit key.</span>
<span>Monoid trees are also binary search trees.</span></p>
</dd>
<dt><span>AVL tree</span></dt>
<dd>
<p><span>Ok, this one I actually don</span>&rsquo;<span>t know a direct application of! </span><em><span>But</span></em><span> I remember two</span>
<span>programming-in-the-small lessons AVL could have taught me, but didn</span>&rsquo;<span>t. I struggled a lot</span>
<span>implementing all of </span>&ldquo;<span>small left rotation</span>&rdquo;<span>, </span>&ldquo;<span>small right rotation</span>&rdquo;<span>, </span>&ldquo;<span>big left rotation</span>&rdquo;<span>, </span>&ldquo;<span>big right</span>
<span>rotation</span>&rdquo;<span>. Some years later, I</span>&rsquo;<span>ve learned that you don</span>&rsquo;<span>t do</span></p>

<figure class="code-block">


<pre><code><span class="line">left: Tree,</span>
<span class="line">right: Tree,</span></code></pre>

</figure>
<p><span>as that forces code duplication. Rather, you do </span><code class="display">children: [Tree; 2]</code><span> and then you could</span>
<span>use </span><code>child_index</code><span> and </span><code>child_index ^ 1</code><span> to abstract over left-right.</span></p>
<p><span>And then some years later still I read in wikipedia that big rotations are actually a composition</span>
<span>of two small rotations.</span></p>
<p><span>Actually, I</span>&rsquo;<span>ve lied that I don</span>&rsquo;<span>t know connections here. You use the same rotations for the splay</span>
<span>tree.</span></p>
</dd>
<dt><span>Red Black Tree</span></dt>
<dd>
<p><span>red-black tree is a 2-3 tree is a B-tree. Also, you probably use jemalloc, and it has a red-black</span>
<span>tree </span><a href="https://github.com/aerospike/jemalloc/blob/05108b5010a511226fb7586543f4162dd2d31d2b/include/jemalloc/internal/rb.h#L338"><span>implemented as a C</span>
<span>macro</span></a><span>.</span>
<span>Left-leaning red-black tree are an interesting variation, which is claimed to be simpler, but is</span>
<span>also claimed to not actually be simpler, because it is not symmetric and neuters the </span><code>children</code>
<span>trick.</span></p>
</dd>
<dt><span>B-tree</span></dt>
<dd>
<p><span>If you use Rust, you probably use B-tree. Also, if you use a database, it stores data either in</span>
<span>LSM or in a B-tree. Both of these are because B-trees play nice with memory hierarchy.</span></p>
</dd>
<dt><span>Splay Tree</span></dt>
<dd>
<p><span>Worth knowing just to have a laugh at </span><a href="https://www.link.cs.cmu.edu/splay/tree5.jpg" class="url">https://www.link.cs.cmu.edu/splay/tree5.jpg</a><span>.</span></p>
</dd>
<dt><span>HashTable</span></dt>
<dd>
<p><span>Literally everywhere, both chaining and open-addressing versions are widely used.</span></p>
</dd>
<dt><span>Depth First Search</span></dt>
<dd>
<p><span>This is something I have to code, explicitly or implicitly, fairly often. Every time where you</span>
<span>have a DAG, when things depend on other things, you</span>&rsquo;<span>d have a DFS somewhere. In rust-analyzer,</span>
<span>there are at least a couple </span>&mdash;<span> one in borrow checker for something (have no idea what that does,</span>
<span>just grepped for </span><code>fn dfs</code><span>) and one in crate graph to detect cycles.</span></p>
</dd>
<dt><span>Breadth First Search</span></dt>
<dd>
<p><span>Ditto, any kind of exploration problem is usually solved with bfs. Eg, rust-analyzer uses </span><code>bfs</code>
<span>for directory traversal.</span></p>
<p><span>Which is better, </span><code>bfs</code><span> or </span><code>dfs</code><span>? Why not both?! Take a look at bdfs from rust-analyzer:</span></p>
<p><a href="https://github.com/rust-lang/rust-analyzer/blob/2fbe69d117ff8e3ffb9b21c4a564f835158eb67b/crates/hir-expand/src/ast_id_map.rs#L195-L222" class="url">https://github.com/rust-lang/rust-analyzer/blob/2fbe69d117ff8e3ffb9b21c4a564f835158eb67b/crates/hir-expand/src/ast_id_map.rs#L195-L222</a></p>
</dd>
<dt><span>Topological Sort</span></dt>
<dd>
<p><span>Again, comes up every time you deal with things which depend on each other. rust-analyzer has</span>
<code>crates_in_topological_order</code></p>
</dd>
<dt><span>Strongly Connected Components</span></dt>
<dd>
<p><span>This is needed every time things depend on each other, but you also allow cyclic dependencies. I</span>
<span>don</span>&rsquo;<span>t think I</span>&rsquo;<span>ve needed this one in real life. But, given that SCC is how you solve 2-SAT in</span>
<span>polynomial time, seems important to know to understand the 3 in 3-SAT</span></p>
</dd>
<dt><span>Minimal Spanning Tree</span></dt>
<dd>
<p><span>Ok, really drawing a blank here! Connects to sorting, disjoint set union (which is needed for</span>
<span>unification in type-checkers), and binary heap. Seems practically important algorithm though! Ah,</span>
<span>MST also gives an approximation for planar traveling salseman I think, another border between hard</span>
<span>&amp; easy problems.</span></p>
</dd>
<dt><span>Dijkstra</span></dt>
<dd>
<p><span>Dijkstra is what I think about when I imagine a Platonic </span><dfn><span>algorithm</span></dfn><span>, though</span>
<span>I don</span>&rsquo;<span>t think I</span>&rsquo;<span>ve used it in practice? Connects to heap.</span></p>
<p><span>Do you know why we use </span><code>i</code><span>, </span><code>j</code><span>, </span><code>k</code><span> for loop indices? Because </span><code>D ijk stra</code><span>!</span></p>
</dd>
<dt><span>Floyd-Warshall</span></dt>
<dd>
<p><span>This one is cool! Everybody knows why any regular expression can be complied to an equivalent</span>
<span>finite state machine. Few people know the reverse, why each automaton has an equivalent regex</span>
<span>(many people know this fact, but few understand why). Well, because Floyd-Warshall! To convert an</span>
<span>automaton to regex use the same algorithm you use to find pairwise distances in a graph.</span></p>
<p><span>Also, this is a final boss of dynamic programming. If you understand why this algorithm works, you</span>
<span>understand dynamic programming. Despite being tricky to understand, it</span>&rsquo;<span>s very easy to implement! I</span>
<span>randomly stumbled into Floyd-Warshall, when I tried to implement a different, wrong approach, and</span>
<span>made a bug which turned my broken algo into a correct Floyd-Warshall.</span></p>
</dd>
<dt><span>Bellman-Ford</span></dt>
<dd>
<p><span>Again, not much practical applicaions here, but the theory is well connected. All shortest path</span>
<span>algorithms are actually fixed-point iterations! But with Bellman-Ford and its explicit edge</span>
<span>relaxation operator that</span>&rsquo;<span>s most obvious. Next time you open static analysis textbook and learn</span>
<span>about fixed point iteration, map that onto the problem of finding shortest paths!</span></p>
</dd>
<dt><span>Quadratic Substring Search</span></dt>
<dd>
<p><span>This is what you language standard library does</span></p>
</dd>
<dt><span>Rabin-Karp</span></dt>
<dd>
<p><span>An excellent application of hashes. The same idea, </span><span class="display"><code>hash(composite) =
compbine(hash(component)*)</code><span>,</span></span><span> is used in rust-analyzer to </span><a href="https://github.com/rust-analyzer/rowan/blob/87909d03dfe78d07ae932151e105dfde7ae87536/src/green/node_cache.rs#L86-L97"><span>intern syntax</span>
<span>trees</span></a><span>.</span></p>
</dd>
<dt><span>Boyer-Moore</span></dt>
<dd>
<p><span>This is beautiful and practical algorithm which probably handles the bulk of real-world searches</span>
<span>(that is, it</span>&rsquo;<span>s probably the hottest bit of </span><code>ripgrep</code><span> as used by an average person). Delightfully,</span>
<span>this algorithm is faster than theoretically possible </span>&mdash;<span> it doesn</span>&rsquo;<span>t even look at every byte of</span>
<span>input data!</span></p>
</dd>
<dt><span>Knuth-Morris-Pratt</span></dt>
<dd>
<p><span>Another </span>&ldquo;<span>this is how you do string search in the real world</span>&rdquo;<span> algorithm. It also is the platonic</span>
<span>ideal of a finite state machine, and almost everything is an FSM. It also is Aho-Corasick.</span></p>
</dd>
<dt><span>Aho-Corasick</span></dt>
<dd>
<p><span>This is the same as Knuth-Morris-Pratt, but also teaches you about tries. Again, super-useful for</span>
<span>string searches. As it is an FSM, and a regex is an FSM, and there</span>&rsquo;<span>s a general construct for</span>
<span>building a product of two FSMs, you can use it to implement fuzzy search. </span>&ldquo;<span>Workspace symbol</span>&rdquo;
<span>feature in rust-analyzer works like this. Here</span>&rsquo;<span>s </span><a href="https://github.com/BurntSushi/fst/pull/64"><span>a part</span>
<span>of</span></a><span> implementation.</span></p>
</dd>
<dt><span>Edit Distance</span></dt>
<dd>
<p><span>Everywhere in Bioinformatics (not the actual edit distance, but this problem shape). The first</span>
<span>post on this blog is about this problem:</span></p>
<p><a href="https://matklad.github.io/2017/03/12/min-of-three.html" class="url">https://matklad.github.io/2017/03/12/min-of-three.html</a></p>
<p><span>It</span>&rsquo;<span>s not about algorithms though, its about CPU-level parallelism.</span></p>
</dd>
</dl>
]]></content>
</entry>

<entry>
<title type="text">Types and the Zig Programming Language</title>
<link href="https://matklad.github.io/2023/08/09/types-and-zig.html" rel="alternate" type="text/html" title="Types and the Zig Programming Language" />
<published>2023-08-09T00:00:00+00:00</published>
<updated>2023-08-09T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/08/09/types-and-zig</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[Notes on less-than-obvious aspects of Zig's type system and things that surprised me after diving
deeper into the language.]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/08/09/types-and-zig.html"><![CDATA[
    <h1>
    <a href="#Types-and-the-Zig-Programming-Language"><span>Types and the Zig Programming Language</span> <time datetime="2023-08-09">Aug 9, 2023</time></a>
    </h1>
<p><span>Notes on less-than-obvious aspects of Zig</span>&rsquo;<span>s type system and things that surprised me after diving</span>
<span>deeper into the language.</span></p>
<section id="Nominal-Types">

    <h2>
    <a href="#Nominal-Types"><span>Nominal Types</span> </a>
    </h2>
<p><span>Zig has a nominal type system despite the fact that types lack names. A struct type is declared by</span>
<span class="display"><code>struct { field: T }</code><span>.</span></span>
<span>It</span>&rsquo;<span>s anonymous; an explicit assignment is required to name the type:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">const</span> S = <span class="hl-keyword">struct</span> {</span>
<span class="line">  field: T,</span>
<span class="line">};</span></code></pre>

</figure>
<p><span>Still, the type system is nominal, not structural. The following does not compile:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> f</span>() <span class="hl-keyword">struct</span> { f: <span class="hl-type">i32</span> } {</span>
<span class="line">  <span class="hl-keyword">return</span> .{ .f = <span class="hl-numbers">92</span> };</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> g</span>(s: <span class="hl-keyword">struct</span> { f: <span class="hl-type">i32</span> }) <span class="hl-type">void</span> {</span>
<span class="line">  _ = s;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> main</span>() <span class="hl-type">void</span> {</span>
<span class="line">  g(f()); <span class="hl-comment">// &lt;- type mismatch</span></span>
<span class="line">}</span></code></pre>

</figure>
<p><span>The following does:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">const</span> S = <span class="hl-keyword">struct</span> { f: <span class="hl-type">i32</span> };</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> f</span>() S {</span>
<span class="line">  <span class="hl-keyword">return</span> .{ .f = <span class="hl-numbers">92</span> };</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> g</span>(s: S) <span class="hl-type">void</span> {</span>
<span class="line">  _ = s;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> main</span>() <span class="hl-type">void</span> {</span>
<span class="line">  g(f());</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>One place where Zig is structural are anonymous struct literals:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> main</span>() <span class="hl-type">void</span> {</span>
<span class="line">  <span class="hl-keyword">const</span> x                      = .{ .foo = <span class="hl-numbers">1</span> };</span>
<span class="line">  <span class="hl-keyword">const</span> y: <span class="hl-keyword">struct</span> { foo: <span class="hl-type">i32</span> } = x;</span>
<span class="line">  <span class="hl-keyword">comptime</span> assert(<span class="hl-built_in">@TypeOf</span>(x) <span class="hl-operator">!=</span> <span class="hl-built_in">@TypeOf</span>(y));</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Types of </span><code>x</code><span> and </span><code>y</code><span> are different, but </span><code>x</code><span> can be coerced to </span><code>y</code><span>.</span></p>
<p><span>In other words, Zig structs are anonymous and nominal, but anonymous structs are structural!</span></p>
</section>
<section id="No-Unification">

    <h2>
    <a href="#No-Unification"><span>No Unification</span> </a>
    </h2>
<p><span>Simple type inference for an expression works by first recursively inferring the types of</span>
<span>subexpressions, and then deriving the result type from that. So, to infer types in</span>
<span class="display"><code>foo().bar()</code><span>,</span></span><span> we first derive the type of </span><code>foo()</code><span>, then lookup method </span><code>bar</code><span> on that</span>
<span>type, and use the return type of the method.</span></p>
<p><span>More complex type inference works through so called unification algorithm. It starts with a similar</span>
<span>recursive walk over the expression tree, but this walk doesn</span>&rsquo;<span>t infer types directly, but rather</span>
<span>assigns a type variable to each subexpression, and generates equations relating type variables. So the</span>
<span>result of this first phase look like this:</span></p>

<figure class="code-block">


<pre><code><span class="line">x = y</span>
<span class="line">Int = y</span></code></pre>

</figure>
<p><span>Then, in the second phase the equations are solved, yielding, in this case, </span><code>x = Int</code><span> and </span><code>y = Int</code><span>.</span></p>
<p><span>Usually languages with powerful type systems have unification somewhere, though often unification</span>
<span>is limited in scope (for example, Kotlin infers types statement-at-a-time).</span></p>
<p><span>It is curious that Zig doesn</span>&rsquo;<span>t do unification, type inference is a simple single-pass recursion (or</span>
<span>at least it should be, I haven</span>&rsquo;<span>t looked at how it is actually implemented). So, anytime there</span>&rsquo;<span>s a</span>
<span>generic function like</span>
<span class="display"><code>fn reverse(comptime T: type, xs: []T) void</code><span>,</span></span>
<span>the call site has to pass the type in explicitly:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> main</span>() <span class="hl-type">void</span> {</span>
<span class="line">  <span class="hl-keyword">var</span> xs: [<span class="hl-numbers">3</span>]<span class="hl-type">i32</span> = .{<span class="hl-numbers">1</span>, <span class="hl-numbers">2</span>, <span class="hl-numbers">3</span>};</span>
<span class="line">  reverse(<span class="hl-type">i32</span>, <span class="hl-operator">&amp;</span>xs);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Does it mean that you have to pass the types all the time? Not really! In fact, the only place which</span>
<span>feels like a burden are functions in </span><code>std.mem</code><span> module which operate on slices, but that</span>&rsquo;<span>s just</span>
<span>because slices are builtin types (a kind of pointer really) without methods. The thing is, when you</span>
<span>call a method on a </span>&ldquo;<span>generic type</span>&rdquo;<span>, its type parameters are implicitly in scope, and don</span>&rsquo;<span>t have to be</span>
<span>specified. Study this example:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">const</span> std = <span class="hl-built_in">@import</span>(<span class="hl-string">&quot;std&quot;</span>);</span>
<span class="line"><span class="hl-keyword">const</span> assert = std.debug.assert;</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> Slice</span>(<span class="hl-keyword">comptime</span> T: <span class="hl-type">type</span>) <span class="hl-type">type</span> {</span>
<span class="line">  <span class="hl-keyword">return</span> <span class="hl-keyword">struct</span> {</span>
<span class="line">    ptr: [<span class="hl-operator">*</span>]T,</span>
<span class="line">    len: <span class="hl-type">usize</span>,</span>
<span class="line"></span>
<span class="line">    <span class="hl-keyword">fn</span><span class="hl-function"> init</span>(ptr: [<span class="hl-operator">*</span>]T, len: <span class="hl-type">usize</span>) <span class="hl-built_in">@This</span>() {</span>
<span class="line">      <span class="hl-keyword">return</span> .{ .ptr = ptr, .len = len };</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hl-keyword">fn</span><span class="hl-function"> reverse</span>(slice: <span class="hl-built_in">@This</span>()) <span class="hl-type">void</span>{</span>
<span class="line">      ...</span>
<span class="line">    }</span>
<span class="line">  };</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> main</span>() <span class="hl-type">void</span> {</span>
<span class="line">  <span class="hl-keyword">var</span> xs: [<span class="hl-numbers">3</span>]<span class="hl-type">i32</span> = .{<span class="hl-numbers">1</span>, <span class="hl-numbers">2</span>, <span class="hl-numbers">3</span>};</span>
<span class="line">  <span class="hl-keyword">var</span> slice = Slice(<span class="hl-type">i32</span>).init(<span class="hl-operator">&amp;</span>xs, xs.len);</span>
<span class="line"></span>
<span class="line">  slice.reverse(); <span class="hl-comment">// &lt;- look, no types!</span></span>
<span class="line">}</span></code></pre>

</figure>
<p><span>There</span>&rsquo;<span>s a runtime parallel here. At runtime, there</span>&rsquo;<span>s a single dynamic dispatch, which prioritizes</span>
<span>dynamic type of the first argument, and multiple dynamic dispatch, which can look at dynamic types</span>
<span>of all arguments. Here, at compile time, the type of the first argument gets a preferential</span>
<span>treatment. And, similarly to runtime, this covers 80% of use cases! Though, I</span>&rsquo;<span>d love for things like</span>
<code>std.mem.eql</code><span> to be actual methods on slices</span>&hellip;</p>
</section>
<section id="Mandatory-Function-Signatures">

    <h2>
    <a href="#Mandatory-Function-Signatures"><span>Mandatory Function Signatures</span> </a>
    </h2>
<p><span>One of the best tricks a language server can pull off for as-you-type analysis is skipping bodies of</span>
<span>the functions in dependencies. This works as long as the language requires complete signatures. In</span>
<span>functional languages, its customary to make signatures optional, which precludes this crucial</span>
<span>optimization. As per </span><a href="https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html"><em><span>Modularity Of Lexical</span>
<span>Analysis</span></em></a><span>, this has</span>
<span>repercussions for all of:</span></p>
<ul>
<li>
<span>incremental compilation,</span>
</li>
<li>
<span>parallel compilation,</span>
</li>
<li>
<span>robustness to errors.</span>
</li>
</ul>
<p><span>I always assumed that Zig with its crazy </span><code>comptime</code><span> requires autopsy.</span>
<span>But that</span>&rsquo;<span>s not actually the case! Zig doesn</span>&rsquo;<span>t have </span><code>decltype(auto)</code><span>, signatures are always explicit!</span></p>
<p><span>Let</span>&rsquo;<span>s look at, e.g., </span><code>std.mem.bytesAsSlice</code><span>:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> bytesAsSlice</span>(</span>
<span class="line">  <span class="hl-keyword">comptime</span> T: <span class="hl-type">type</span>,</span>
<span class="line">  bytes: <span class="hl-type">anytype</span>,</span>
<span class="line">) BytesAsSliceReturnType(T, <span class="hl-built_in">@TypeOf</span>(bytes)) {</span></code></pre>

</figure>
<p><span>Note how the return type is not </span><code>anytype</code><span>, but the actual, real thing. You could write complex</span>
<span>computations there, but you can</span>&rsquo;<span>t look inside the body. Of course, it also is possible to write </span><span class="display"><code>fn
foo() @TypeOf(bar()) {</code><span>,</span></span><span> but that feels like a fair game </span>&mdash;<span> </span><code>bar()</code><span> will be evaluated at</span>
<span>compile time. In other words, only bodies of functions invoked at comptime needs to be looked at by</span>
<span>a language server. This potentially improves performance for this use-case quite a bit!</span></p>
<p><span>It</span>&rsquo;<span>s useful to contrast this with Rust. There, you could write</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">sneaky</span>() <span class="hl-punctuation">-&gt;</span> <span class="hl-keyword">impl</span> <span class="hl-title class_">Sized</span> {</span>
<span class="line">  <span class="hl-number">0i32</span></span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Although it feels like you are stating the interface, it</span>&rsquo;<span>s not really the case. Auto traits like</span>
<code>Send</code><span> and </span><code>Sync</code><span> leak, and that can be detected by downstream code and lead to, e.g., different</span>
<span>methods being called via </span><code>Deref</code><span>-based specialization depending on </span><code>: Send</code><span> being implemented:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">X</span>&lt;T&gt;(T);</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">impl</span>&lt;T: <span class="hl-built_in">Send</span>&gt; X&lt;T&gt; {</span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">foo</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">i32</span> { todo!() }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Y</span>;</span>
<span class="line"><span class="hl-keyword">impl</span> <span class="hl-title class_">Y</span> {</span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">foo</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">String</span> { todo!() }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">impl</span>&lt;T&gt; std::ops::Deref <span class="hl-keyword">for</span> <span class="hl-title class_">X</span>&lt;T&gt; {</span>
<span class="line">  <span class="hl-keyword">type</span> <span class="hl-title class_">Target</span> = Y;</span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">deref</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;Y { todo!() }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">f</span>() <span class="hl-punctuation">-&gt;</span> <span class="hl-keyword">impl</span> <span class="hl-title class_">Sized</span> {</span>
<span class="line">  ()</span>
<span class="line"><span class="hl-comment">//  std::rc::Rc::new(())</span></span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">main</span>() {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">x</span> = <span class="hl-title function_ invoke__">X</span>(<span class="hl-title function_ invoke__">f</span>());</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">t</span> = x.<span class="hl-title function_ invoke__">foo</span>(); <span class="hl-comment">// &lt;- which `foo`?</span></span>
<span class="line">  <span class="hl-comment">// The answer is inside f&#x27;s body!</span></span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Zig is much more strict here, you have to fully name the return type (the name doesn</span>&rsquo;<span>t have to be</span>
<span>pretty, take a second look at </span><code>bytesAsSlice</code><span>). But its not perfect, a genuine leakage happens  with</span>
<span>inferred error types (</span><code>!T</code><span> syntax). A bad example would look like this:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> f</span>() <span class="hl-operator">!</span><span class="hl-type">void</span> {</span>
<span class="line">   <span class="hl-comment">// Mystery!</span></span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> main</span>() <span class="hl-operator">!</span><span class="hl-type">void</span> {</span>
<span class="line">  f() <span class="hl-keyword">catch</span> <span class="hl-operator">|</span>err<span class="hl-operator">|</span> {</span>
<span class="line">    <span class="hl-keyword">comptime</span> assert(</span>
<span class="line">      <span class="hl-built_in">@typeInfo</span>(<span class="hl-built_in">@TypeOf</span>(err)).ErrorSet.?.len <span class="hl-operator">==</span> <span class="hl-numbers">1</span>,</span>
<span class="line">    );</span>
<span class="line">  };</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Here, to check </span><code>main</code><span>, we actually do need to dissect </span><code>f</code>&rsquo;<span>s body, we can</span>&rsquo;<span>t treat the error union</span>
<span>abstractly. When the compiler analyzes </span><code>main</code><span>, it needs to stop to process </span><code>f</code><span> signature (which is</span>
<span>very fast, as it is very short) and then </span><code>f</code><span>’s body (this part could be quite slow, there might be a</span>
<span>lot of code behind that </span><code>Mystery</code><span>! It</span>&rsquo;<span>s interesting to ponder alternative semantics, where, during</span>
<span>type checking, inferred types are treated abstractly, and error exhastiveness is a separate late</span>
<span>pass in the compiler. That way, complier only needs </span><code>f</code>&rsquo;<span>s signature to check </span><code>main</code><span>. And that means</span>
<span>that bodies of </span><code>main</code><span> and </span><code>f</code><span> could be checked in parallel.</span></p>
<p><span>That</span>&rsquo;<span>s all for today! The type system surprising I</span>&rsquo;<span>ve found so far are:</span></p>
<ul>
<li>
<p><span>Nominal type system despite notable absence of names of types.</span></p>
</li>
<li>
<p><span>Unification-less generics which don</span>&rsquo;<span>t incur unreasonable annotation burden due to methods </span>&ldquo;<span>closing</span>
<span>over</span>&rdquo;<span> generic parameters.</span></p>
</li>
<li>
<p><span>Explicit signatures with no </span><a href="https://wiki.dlang.org/Voldemort_types"><span>Voldemort types</span></a><span> with a</span>
<span>notable exception of error unions.</span></p>
</li>
</ul>
<p><span>Discussion on </span><a href="https://ziggit.dev/t/types-and-the-zig-programming-language/1430"><span>ziggit.dev</span></a><span>.</span></p>
</section>
]]></content>
</entry>

<entry>
<title type="text">Fantastic Learning Resources</title>
<link href="https://matklad.github.io/2023/08/06/fantastic-learning-resources.html" rel="alternate" type="text/html" title="Fantastic Learning Resources" />
<published>2023-08-06T00:00:00+00:00</published>
<updated>2023-08-06T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/08/06/fantastic-learning-resources</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[People sometimes ask me: Alex, how do I learn X?. This article is a compilation of advice I
usually give. This is things that worked for me rather than the most awesome things on earth. I
do consider every item on the list to be fantastic though, and I am forever grateful to people
putting these resources together.]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/08/06/fantastic-learning-resources.html"><![CDATA[
    <h1>
    <a href="#Fantastic-Learning-Resources"><span>Fantastic Learning Resources</span> <time datetime="2023-08-06">Aug 6, 2023</time></a>
    </h1>
<p><span>People sometimes ask me: </span>&ldquo;<span>Alex, how do I learn X?</span>&rdquo;<span>. This article is a compilation of advice I</span>
<span>usually give. This is </span>&ldquo;<span>things that worked for me</span>&rdquo;<span> rather than </span>&ldquo;<span>the most awesome things on earth</span>&rdquo;<span>. I</span>
<span>do consider every item on the list to be fantastic though, and I am forever grateful to people</span>
<span>putting these resources together.</span></p>
<section id="Learning-to-Code">

    <h2>
    <a href="#Learning-to-Code"><span>Learning to Code</span> </a>
    </h2>
<p><span>I don</span>&rsquo;<span>t think I have any useful advice on how to learn programming from zero. The rest of the post</span>
<span>assumes that you at least can, given sufficient time, write simple programs. E.g., a program that</span>
<span>reads a list of integers from an input textual file, sorts them using a quadratic algorithm, and</span>
<span>writes the result to a different file.</span></p>
</section>
<section id="Project-Euler">

    <h2>
    <a href="#Project-Euler"><span>Project Euler</span> </a>
    </h2>
<p><a href="https://projecteuler.net/archives" class="url">https://projecteuler.net/archives</a><span> is fantastic. The first 50 problems or so are a perfect </span>&ldquo;<span>drill</span>&rdquo;
<span>to build programming muscle, to go from </span>&ldquo;<span>I can write a program to sort a list of integers</span>&rdquo;<span> to </span>&ldquo;<span>I can</span>
<em><span>easily</span></em><span> write a program to sort a list of integers</span>&rdquo;<span>.</span></p>
<p><span>Later problems are very heavily math based. If you are mathematically inclined, this is perfect </span>&mdash;
<span>you got to solve fun puzzles while also practicing coding. If advanced math isn</span>&rsquo;<span>t your cup of tea,</span>
<span>feel free to stop doing problems as soon as it stops being fun.</span></p>
</section>
<section id="Modern-Operating-System">

    <h2>
    <a href="#Modern-Operating-System"><span>Modern Operating System</span> </a>
    </h2>
<p><a href="https://en.wikipedia.org/wiki/Modern_Operating_Systems" class="url">https://en.wikipedia.org/wiki/Modern_Operating_Systems</a><span> is fantastic. A </span><a href="https://en.wikipedia.org/wiki/Operating_Systems:_Design_and_Implementation"><span>version of the</span>
<span>book</span></a><span> was the first</span>
<span>thick programming related tome I devoured. It gives a big picture of the inner workings of software</span>
<span>stack, and was a turning point for me personally. After reading this book I realized that I want to</span>
<span>be a programmer.</span></p>
</section>
<section id="Nand-to-Tetris">

    <h2>
    <a href="#Nand-to-Tetris"><span>Nand to Tetris</span> </a>
    </h2>
<p><a href="https://www.nand2tetris.org" class="url">https://www.nand2tetris.org</a><span> is fantastic. It plays a similar </span>&ldquo;<span>big picture</span>&rdquo;<span> role as MOS,</span>
<span>but this time you are the painter. In this course you build a whole computing system yourself,</span>
<span>starting almost from nothing. It doesn</span>&rsquo;<span>t teach you how the real software/hardware stack works, but</span>
<span>it thoroughly dispels any magic, and is extremely fun.</span></p>
</section>
<section id="CSES-Problem-Set">

    <h2>
    <a href="#CSES-Problem-Set"><span>CSES Problem Set</span> </a>
    </h2>
<p><a href="https://cses.fi/problemset/" class="url">https://cses.fi/problemset/</a><span> is fantastic. This is a list of algorithmic problems, which is</span>
<span>meticulously crafted to cover all the standard topics to a reasonable depth. This is by far the best</span>
<span>source for practicing algorithms.</span></p>
</section>
<section id="Programming-Languages">

    <h2>
    <a href="#Programming-Languages"><span>Programming Languages</span> </a>
    </h2>
<p><a href="https://www.coursera.org/learn/programming-languages" class="url">https://www.coursera.org/learn/programming-languages</a><span> is fantastic. This course is a whirlwind tour</span>
<span>across several paradigms of programming, and makes you really </span><em><span>get</span></em><span> what programming languages are</span>
<span>about (and variance).</span></p>
</section>
<section id="Compilers">

    <h2>
    <a href="#Compilers"><span>Compilers</span> </a>
    </h2>
<p><a href="http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=Compilers" class="url">http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=Compilers</a><span> is fantastic. In this</span>
<span>course, you implement a working compiler for a simple, but real programming language. Note that you</span>
<span>can implement your compiler in any language.</span></p>
</section>
<section id="Software-Architecture">

    <h2>
    <a href="#Software-Architecture"><span>Software Architecture</span> </a>
    </h2>
<p><a href="https://www.tedinski.com/archive/" class="url">https://www.tedinski.com/archive/</a><span> is fantastic. Work through the whole archive in chronological</span>
<span>order. This is by far the best resource on </span>&ldquo;<span>programming in the large</span>&rdquo;<span>.</span></p>
</section>
<section id="Random-Bits-of-Advice">

    <h2>
    <a href="#Random-Bits-of-Advice"><span>Random Bits of Advice</span> </a>
    </h2>
<p><span>What follows are some things I</span>&rsquo;<span>ve learned for myself. Take with a pinch of salt!</span></p>
<section id="On-Mentorship">

    <h3>
    <a href="#On-Mentorship"><span>On Mentorship</span> </a>
    </h3>
<p><span>Having a great mentor is fantastic, but mentors are not always available. Luckily, programming can</span>
<span>be mastered without a mentor, if you got past the initial learning step. When you code, you get </span><em><span>a</span>
<span>lot</span></em><span> of feedback, and, through trial and error, you can process the feedback to improve your skills.</span>
<span>In fact, the hardest bit is actually finding the problems to solve (and this article suggests many).</span>
<span>But if you have the problem, you can self-improve noticing the following:</span></p>
<ul>
<li>
<span>How you verify that the solution works.</span>
</li>
<li>
<span>Common bugs and techniques to avoid them in the future.</span>
</li>
<li>
<span>Length of the solution: can you solve the problem using shorter, simpler code?</span>
</li>
<li>
<span>Techniques </span>&mdash;<span> can you apply anything you</span>&rsquo;<span>ve read about this week? How would the problem be solved</span>
<span>in Haskell? Could you apply pattern from language X in language Y?</span>
</li>
</ul>
<p><span>In this context it is important to solve the same problem repeatedly. E.g., you could try solving</span>
<span>the same model problem in all languages you know, with a month or two break between attempts.</span>
<span>Repeatedly doing the same thing and noticing differences and similarities between tries is the</span>
<span>essence of self-learning.</span></p>
</section>
<section id="On-Programming-Languages">

    <h3>
    <a href="#On-Programming-Languages"><span>On Programming Languages</span> </a>
    </h3>
<p><span>Learning your first programming language is a nightmare, because you are learning your editing</span>
<span>environment (PyScripter, IntelliJ IDEA, VS Code) first, simple algorithms second, and the language</span>
<span>itself third. It gets much easier afterwards!</span></p>
<p><span>Learning different programming languages is one of the best way to improve your programming skills.</span>
<span>By seeing what</span>&rsquo;<span>s similar, and what</span>&rsquo;<span>s different, you deeper learn how the things work under the hood.</span>
<span>Different languages put different idioms to the forefront, and learning several expands your</span>
<span>vocabulary considerably. As a bonus, after learning N languages, learning N+1st becomes a question</span>
<span>of skimming through the official docs.</span></p>
<p><span>In general, you want to cover big families of languages: Python, Java, Haskell, C, Rust, Clojure</span>
<span>would be a good baseline. Erlang, Forth, and Prolog would be good additions afterwards.</span></p>
</section>
<section id="On-Algorithms">

    <h3>
    <a href="#On-Algorithms"><span>On Algorithms</span> </a>
    </h3>
<p><span>There are three levels of learning algorithms</span></p>
<dl>
<dt><span>Level 1</span></dt>
<dd>
<p><span>You are not actually learning algorithms, you are learning programming. At this stage, it doesn</span>&rsquo;<span>t</span>
<span>matter how long your code is, how pretty it is, or how efficient it is. The only thing that</span>
<span>matters is that it solves the problem. Generally, this level ends when you are fairly comfortable</span>
<span>with recursion. Few first problems from Project Euler are a great resource here.</span></p>
</dd>
<dt><span>Level 2</span></dt>
<dd>
<p><span>Here you learn algorithms proper. The goal here is mostly encyclopedic knowledge of common</span>
<span>techniques. There are quite a few, but not too many of those. At this stage, the most useful thing</span>
<span>is understanding the math behind the algorithms </span>&mdash;<span> being able to explain algorithm using</span>
<span>pencil&amp;paper, prove its correctness, and analyze Big-O runtime. Generally, you want to learn the</span>
<span>name of algorithm or technique, read and grok the full explanation, and then implement it.</span></p>
<p><span>I recommend doing an abstract implementation first (i.e., not </span>&ldquo;<span>HashMap to solve problem X</span>&rdquo;<span>, but</span>
&ldquo;<span>just HashMap</span>&rdquo;<span>). Include tests in your implementation. Use randomized testing (e.g., when testing</span>
<span>sorting algorithms, don</span>&rsquo;<span>t use a finite set of example, generate a million random ones).</span></p>
<p><span>It</span>&rsquo;<span>s OK and even desirable to implement the same algorithm multiple times. When solving problems,</span>
<span>like CSES, you </span><em><span>could</span></em><span> abstract your solutions and re-use them, but it</span>&rsquo;<span>s better to code everything</span>
<span>from scratch every time, until you</span>&rsquo;<span>ve fully internalized the algorithm.</span></p>
</dd>
<dt><span>Level 3</span></dt>
<dd>
<p><span>One day, long after I</span>&rsquo;<span>ve finished my university, I was a TA for an algorithms course. The lecturer</span>
<span>for the course was the person who originally taught me to program, through a similar algorithms</span>
<span>course. And, during one coffee break, he said something like</span></p>

<figure class="blockquote">
<blockquote><p><span>We don</span>&rsquo;<span>t teach algorithms so that students can code Dijkstra with their eyes closed on the job.</span>
<span>They probably won</span>&rsquo;<span>t have to code any fancy algorithms themselves.</span></p>
<p><span>We teach algorithms so that students learn to think about invariants and properties when writing</span>
<span>code. Real-life code is usually simple enough that it mostly works if you just throw spaghetti</span>
<span>onto the wall. But it doesn</span>&rsquo;<span>t always work. To write correct, robust code at work, you need to</span>
<span>think about invariants.</span></p>
<p><span>The trick with algorithms is that coding them is hard. The only way to avoid bugs is to force</span>
<span>yourself to think in terms of invariants.</span></p>
</blockquote>

</figure>
<p><span>I was thunderstruck! I didn</span>&rsquo;<span>t realize that</span>&rsquo;<span>s the reason why I am learning (well, teaching at that</span>
<span>point) algorithms! Before, I always muddled through my algorithms by randomly tweaking generally</span>
<span>correct stuff until it works. E.g., with a binary search, just add </span><code>+1</code><span> somewhere until it doesn</span>&rsquo;<span>t</span>
<span>loop on random arrays. After hearing this advice, I went home and wrote my millionth binary</span>
<span>search, but this time I actually added comments with loop invariants, and it worked from the first</span>
<span>try! I applied similar techniques for the rest of the course, and since then my subjective</span>
<span>perception of bug rate (for normal work code) went down dramatically.</span></p>
<p><span>So this is the third level of algorithms </span>&mdash;<span> you hone your coding skills to program without bugs.</span>
<span>If you are already fairly comfortable with algorithms, try doing CSES again. But this time, spend</span>
<span>however much you need double-checking the code </span><em><span>before</span></em><span> submission, but try to get everything</span>
<span>correct on the first try.</span></p>
</dd>
</dl>
</section>
<section id="On-Algorithm-Names">

    <h3>
    <a href="#On-Algorithm-Names"><span>On Algorithm Names</span> </a>
    </h3>
<p><span>Here</span>&rsquo;<span>s the list of things you might want to be able to do, algorithmically. You don</span>&rsquo;<span>t need to be</span>
<span>able to code everything on the spot. I think it would help if you know what each word is about, and</span>
<span>have implemented the thing at least once in the past.</span></p>
<p><span>Linear search, binary search, quadratic sorting, quick sort, merge sort, heap sort, binary heap,</span>
<span>growable array (aka ArrayList, vector), doubly-linked list, binary search tree, avl tree, red-black</span>
<span>tree, B-tree, splay tree, hash table (chaining and open addressing), depth first search, breadth first</span>
<span>search, topological sort, strongly connected components, minimal spanning tree (Prim &amp; Kruskal),</span>
<span>shortest paths (bfs, Dijkstra, Floyd–Warshall, Bellman–Ford), substring search (quadratic,</span>
<span>Rabin-Karp, Boyer-Moore, Knuth-Morris-Pratt), trie, Aho-Corasick, dynamic programming (longest</span>
<span>common subsequence, edit distance).</span></p>
</section>
<section id="On-Larger-Programs">

    <h3>
    <a href="#On-Larger-Programs"><span>On Larger Programs</span> </a>
    </h3>
<p><span>A very powerful exercise is coding a medium-sized project from scratch. Something that takes more</span>
<span>than a day, but less than a week, and has a meaningful architecture which can be just right, or</span>
<span>messed up. Here are some great projects to do:</span></p>
<dl>
<dt><span>Ray Tracer</span></dt>
<dd>
<p><span>Given an analytical description of a 3D scene, convert it to a colored 2D image, by simulating a</span>
<span>path of a ray of light as it bounces off objects.</span></p>
</dd>
<dt><span>Software Rasterizer</span></dt>
<dd>
<p><span>Given a description of a 3D scene as a set of triangles, convert it to a colored 2D image by</span>
<span>projecting triangles onto the viewing plane and drawing the projections in the correct order.</span></p>
</dd>
<dt><span>Dynamically Typed Programming Language</span></dt>
<dd>
<p><span>An </span><em><span>interpreter</span></em><span> which reads source code as text, parses it into an AST, and directly executes the</span>
<span>AST (or maybe converts AST to the byte code for some speed up)</span></p>
</dd>
<dt><span>Statically Typed Programming Language</span></dt>
<dd>
<p><span>A </span><em><span>compiler</span></em><span> which reads source code as text, and spits out a binary (WASM would be a terrific</span>
<span>target).</span></p>
</dd>
<dt><span>Relational Database</span></dt>
<dd>
<p><span>Several components:</span></p>
<ul>
<li>
<span>Storage engine, which stores data durably on disk and implements on-disk ordered data structures</span>
<span>(B-tree or LSM)</span>
</li>
<li>
<span>Relational data model which is implemented on top of primitive ordered data structures.</span>
</li>
<li>
<span>Relational language to express schema and queries.</span>
</li>
<li>
<span>Either a TCP server to accept transactions as a database server, or an API for embedding for an</span>
<span>in-processes </span>&ldquo;<span>embedded</span>&rdquo;<span> database.</span>
</li>
</ul>
</dd>
<dt><span>Chat Server</span></dt>
<dd>
<p><span>An exercise in networking and asynchronous programming. Multiple client programs connect to a</span>
<span>server program. A client can send a message either to a specific different client, or to all other</span>
<span>clients (broadcast). There are many variations on how to implement this: blocking read/write</span>
<span>calls, </span><code>epoll</code><span>, </span><code>io_uring</code><span>, threads, callbacks, futures, manually-coded state machines.</span></p>
</dd>
</dl>
<p><span>Again, it</span>&rsquo;<span>s more valuable to do the same exercise six times with variations, than to blast through</span>
<span>everything once.</span></p>
</section>
</section>
]]></content>
</entry>

<entry>
<title type="text">On Modularity of Lexical Analysis</title>
<link href="https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html" rel="alternate" type="text/html" title="On Modularity of Lexical Analysis" />
<published>2023-08-01T00:00:00+00:00</published>
<updated>2023-08-01T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[I was going to write a long post about designing an IDE-friendly language. I wrote an intro and
figured that it would make a better, shorter post on its own. Enjoy!]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html"><![CDATA[
    <h1>
    <a href="#On-Modularity-of-Lexical-Analysis"><span>On Modularity of Lexical Analysis</span> <time datetime="2023-08-01">Aug 1, 2023</time></a>
    </h1>
<p><span>I was going to write a long post about designing an IDE-friendly language. I wrote an intro and</span>
<span>figured that it would make a better, shorter post on its own. Enjoy!</span></p>
<p><span>The big idea of language server construction is that language servers are not magic </span>&mdash;<span> capabilities</span>
<span>and performance of tooling are constrained by the syntax and semantics of the underlying language.</span>
<span>If a language is not designed with toolability in mind, some capabilities (e.g, fully automated</span>
<span>refactors) are impossible to implement correctly. What</span>&rsquo;<span>s more, an IDE-friendly language turns out to</span>
<span>be a fast-to-compile language with easy-to-compose libraries!</span></p>
<p><span>More abstractly, there</span>&rsquo;<span>s this cluster of unrelated at a first sight, but intimately intertwined and</span>
<span>mutually supportive properties:</span></p>
<ul>
<li>
<span>parallel, separate compilation,</span>
</li>
<li>
<span>incremental compilation,</span>
</li>
<li>
<span>resilience to errors.</span>
</li>
</ul>
<p><span>Separate compilation measures how fast we can compile codebase from scratch if we have unlimited</span>
<span>number of CPU cores. For a language server, it solves the cold start problem </span>&mdash;<span> time to</span>
<span>code-completion when the user opens the project for the first time or switches branches. Incremental</span>
<span>compilation is the steady state of the language server </span>&mdash;<span> user types code and expects to see</span>
<span>immediate effects throughout the project. Resilience to errors is important for two different</span>
<span>sub-reasons. First, when the user edits the code it is by definition incomplete and erroneous, but a</span>
<span>language server still must analyze the surrounding context correctly. But the killer feature of</span>
<span>resilience is that, if you are absolutely immune to some errors, you don</span>&rsquo;<span>t even have to look at the</span>
<span>code. If a language server can ignore errors in function bodies, it doesn</span>&rsquo;<span>t have to look at the</span>
<span>bodies of functions from dependencies.</span></p>
<p><span>All three properties, parallelism, incrementality, and resilience, boil down to modularity </span>&mdash;
<span>partitioning the code into disjoint components with well-defined interfaces, such that each</span>
<span>particular component is aware only about the interfaces of other components.</span></p>
<section id="Minimized-Example-Lexical-Analysis">

    <h2>
    <a href="#Minimized-Example-Lexical-Analysis"><span>Minimized Example: Lexical Analysis</span> </a>
    </h2>
<p><span>Lets do a short drill and observe how the three properties interact at a small scale. Let</span>&rsquo;<span>s</span>
<span>minimize the problem of separate compilation to just </span>&hellip;<span> lexical analysis. How can we build a</span>
<span>language that is easier to tokenize for an language server?</span></p>
<p><span>An unclosed quote is a nasty little problem! Practically, it is rare enough that it doesn</span>&rsquo;<span>t really</span>
<span>matter how you handle it, but qualitatively it is illuminating. In a language like Rust, where</span>
<span>strings can span multiple lines, inserting a </span><code>"</code><span> in the middle of a file changes the lexical structure</span>
<span>of the following text completely (</span><code>/*</code><span>, start of a block comment, has the same effect). When tokens</span>
<span>change, so does the syntax tree and the set of symbols defined by the file. A tiny edit, just one</span>
<span>symbol, unhinges semantic structure of the entire compilation unit.</span></p>
<p><span>Zig solves this problem. In Zig, no token can span several lines. That is, it would be correct to</span>
<span>first split Zig source file by </span><code>\n</code><span>, and then tokenize each line separately. This is achieved by</span>
<span>solving underlying problems requiring multi-line tokens better. Specifically:</span></p>
<ul>
<li>
<p><span>there</span>&rsquo;<span>s a single syntax for comments, </span><code>//</code><span>,</span></p>
</li>
<li>
<p><span>double-quoted strings can</span>&rsquo;<span>t contain a </span><code>\n</code><span>,</span></p>
</li>
<li>
<p><span>but there</span>&rsquo;<span>s a really nice syntax for multiline strings:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">const</span> greeting =</span>
<span class="line">    <span class="hl-string">\\This is</span></span>
<span class="line">    <span class="hl-string">\\a multiline string</span></span>
<span class="line">    <span class="hl-string">\\   &lt;- with a leading whitespace here.</span></span>
<span class="line">    <span class="hl-string">\\</span></span></code></pre>

</figure>
</li>
</ul>
<p><span>Do you see modules here? Disjoint-partitioning into interface-connected components? From the</span>
<span>perspective of lexical analysis, each </span><em><span>line</span></em><span> is a module. And a line always has a trivial, empty</span>
<span>interface </span>&mdash;<span> different lines are completely independent. As a result:</span></p>
<p><em><span>First</span></em><span>, we can do lexical analysis in parallel. If you have N CPU cores, you can split file into N</span>
<span>equal chunks, then in parallel locally adjust chunk boundaries such that they fall on newlines, and</span>
<span>then tokenize each chunk separately.</span></p>
<p><em><span>Second</span></em><span>, we have quick incremental tokenization </span>&mdash;<span> given a source edit, you determine the set of</span>
<span>lines affected, and re-tokenize only those. The work is proportional to the size of the edit plus at</span>
<span>most two boundary lines.</span></p>
<p><em><span>Third</span></em><span>, any lexical error in a line is isolated just to this line. There</span>&rsquo;<span>s no unclosed quote</span>
<span>problem, mistakes are contained.</span></p>
<p><span>I am by no means saying that line-by-line lexing is a requirement for an IDE-friendly language</span>
<span>(though it would be nice)! Rather, I want you to marvel how the same underlying structure of the</span>
<span>problem can be exploited for quarantining errors, reacting to changes quickly, and parallelizing the</span>
<span>processing.</span></p>
<p><span>The three properties are just three different faces of modularity in the end!</span></p>
<hr>
<p><span>I do want to write that </span>&ldquo;<span>IDE-friendly language</span>&rdquo;<span> post at some point, but, as a hedge (after all, I</span>
<span>still owe you </span>&ldquo;<a href="https://matklad.github.io/2022/04/25/why-lsp.html"><span>Why LSP</span></a><span> Sucks?</span>&rdquo;<span> one</span>&hellip;<span>), here are two comments where I explored the idea somewhat:</span>
<a href="https://todo.sr.ht/~icefox/garnet/52#event-242650"><span>1</span></a><span>,</span>
<a href="https://lobste.rs/s/u7y4lk/modules_matter_most_for_masses#c_i6a8n9"><span>2</span></a><span>.</span></p>
<p><span>I also recommend these posts, which explore the same underlying phenomenon from the software</span>
<span>architecture perspective:</span></p>
<ul>
<li>
<a href="https://www.tedinski.com/2018/01/30/the-one-ring-problem-abstraction-and-power.html" class="url">https://www.tedinski.com/2018/01/30/the-one-ring-problem-abstraction-and-power.html</a>
</li>
<li>
<a href="https://www.tedinski.com/2018/02/06/system-boundaries.html" class="url">https://www.tedinski.com/2018/02/06/system-boundaries.html</a>
</li>
<li>
<a href="https://www.pathsensitive.com/2023/03/modules-matter-most-for-masses.html" class="url">https://www.pathsensitive.com/2023/03/modules-matter-most-for-masses.html</a>
</li>
</ul>
</section>
]]></content>
</entry>

<entry>
<title type="text">Three Different Cuts</title>
<link href="https://matklad.github.io/2023/07/16/three-different-cuts.html" rel="alternate" type="text/html" title="Three Different Cuts" />
<published>2023-07-16T00:00:00+00:00</published>
<updated>2023-07-16T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/07/16/three-different-cuts</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[In this post, we'll look at how Rust, Go, and Zig express the signature of function cut --- the power tool of string manipulation.
Cut takes a string and a pattern, and splits the string around the first occurrence of the pattern:
cut("life", "if") = ("l", "e").]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/07/16/three-different-cuts.html"><![CDATA[
    <h1>
    <a href="#Three-Different-Cuts"><span>Three Different Cuts</span> <time datetime="2023-07-16">Jul 16, 2023</time></a>
    </h1>
<p><span>In this post, we</span>&rsquo;<span>ll look at how Rust, Go, and Zig express the signature of function </span><code>cut</code><span> </span>&mdash;<span> the power tool of string manipulation.</span>
<span>Cut takes a string and a pattern, and splits the string around the first occurrence of the pattern:</span>
<span class="display"><code>cut("life", "if") = ("l", "e")</code><span>.</span></span></p>
<p><span>At a glance, it seems like a non-orthogonal jumbling together of searching and slicing.</span>
<span>However, in practice a lot of ad-hoc string processing can be elegantly expressed via </span><code>cut</code><span>.</span></p>
<p><span>A lot of things are </span><code>key=value</code><span> pairs, and cut fits perfectly there.</span>
<span>What</span>&rsquo;<span>s more, many more complex sequencies, like</span>
<span class="display"><code>--arg=key=value</code><span>,</span></span>
<span>can be viewed as nested pairs.</span>
<span>You can cut around </span><code>=</code><span> once to get </span><code>--arg</code><span> and </span><code>key=value</code><span>, and then cut the second time to separate </span><code>key</code><span> from </span><code>value</code><span>.</span></p>
<p><span>In Rust, this function looks like this:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">split_once</span>&lt;<span class="hl-symbol">&#x27;a</span>, P&gt;(</span>
<span class="line">  &amp;<span class="hl-symbol">&#x27;a</span> <span class="hl-keyword">self</span>,</span>
<span class="line">  delimiter: P,</span>
<span class="line">) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">Option</span>&lt;(&amp;<span class="hl-symbol">&#x27;a</span> <span class="hl-type">str</span>, &amp;<span class="hl-symbol">&#x27;a</span> <span class="hl-type">str</span>)&gt;</span>
<span class="line"><span class="hl-keyword">where</span></span>
<span class="line">  P: Pattern&lt;<span class="hl-symbol">&#x27;a</span>&gt;,</span>
<span class="line">{</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Rust</span>&rsquo;<span>s </span><code>Option</code><span> is a good fit for the result type, it clearnly describes the behavior of the function when the pattern isn</span>&rsquo;<span>t found in the string at all.</span>
<span>Lifetime </span><code>'a</code><span> expresses the relationship between the result and the input </span>&mdash;<span> both pieces of result are substrings of </span><code>&amp;'a self</code><span>, so, as long as they are used, the original string must be kept alive as well.</span>
<span>Finally, the separator isn</span>&rsquo;<span>t another string, but a generic </span><code>P: Pattern</code><span>.</span>
<span>This gives a somewhat crowded signature, but allows using strings, single characters, and even </span><code class="display">fn(c: char) -&gt; bool</code><span> functions as patterns.</span></p>
<p><span>When using the function, there are is a multitude of ways to access the result:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// Propagate `None` upwards:</span></span>
<span class="line"><span class="hl-keyword">let</span> (prefix, suffix) = line.<span class="hl-title function_ invoke__">split_once</span>(<span class="hl-string">&quot;=&quot;</span>)?;</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Handle `None` in an ad-hoc way:</span></span>
<span class="line"><span class="hl-keyword">let</span> <span class="hl-variable">Some</span>((prefix, suffix)) = line.<span class="hl-title function_ invoke__">split_once</span>(<span class="hl-string">&quot;=&quot;</span>) <span class="hl-keyword">else</span> {</span>
<span class="line">    <span class="hl-keyword">return</span></span>
<span class="line">};</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Ignore `None`:</span></span>
<span class="line"><span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>((prefix, suffix)) = line.<span class="hl-title function_ invoke__">split_once</span>(<span class="hl-string">&quot;=&quot;</span>) {</span>
<span class="line">    ...</span>
<span class="line">};</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Handle `Some` and `None` in a symmetric way:</span></span>
<span class="line"><span class="hl-keyword">let</span> <span class="hl-variable">result</span> = <span class="hl-keyword">match</span> line.<span class="hl-title function_ invoke__">split_once</span>(<span class="hl-string">&quot;=&quot;</span>) {</span>
<span class="line">    <span class="hl-title function_ invoke__">Some</span>((prefix, suffix)) =&gt; { ... }</span>
<span class="line">    <span class="hl-literal">None</span> =&gt; { ... }</span>
<span class="line">};</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Access only one component of the result:</span></span>
<span class="line"><span class="hl-keyword">let</span> <span class="hl-variable">suffix</span> = line.<span class="hl-title function_ invoke__">split_once</span>(<span class="hl-string">&quot;=&quot;</span>)?.<span class="hl-number">1</span>;</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Use high-order functions to extract key with a default:</span></span>
<span class="line"><span class="hl-keyword">let</span> <span class="hl-variable">key</span> = line.<span class="hl-title function_ invoke__">split_once</span>(<span class="hl-string">&quot;=&quot;</span>)</span>
<span class="line">    .<span class="hl-title function_ invoke__">map</span>(|(key, _value)| key)</span>
<span class="line">    .<span class="hl-title function_ invoke__">unwrap_or</span>(line);</span></code></pre>

</figure>
<p><span>Here</span>&rsquo;<span>s a Go equivalent:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-function"><span class="hl-keyword">func</span> <span class="hl-title">Cut</span><span class="hl-params">(s, sep <span class="hl-type">string</span>)</span></span> (before, after <span class="hl-type">string</span>, found <span class="hl-type">bool</span>) {</span>
<span class="line">    ...</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>It has a better name!</span>
<span>It</span>&rsquo;<span>s important that frequently used building-block functions have short, memorable names, and </span>&ldquo;<span>cut</span>&rdquo;<span> is just perfect for what the function does.</span>
<span>Go doesn</span>&rsquo;<span>t have an </span><code>Option</code><span>, but it allows multiple return values, and any type in Go has a zero value, so a boolean flag can be used to signal </span><code>None</code><span>.</span>
<span>Curiously if the </span><code>sep</code><span> is not found in </span><code>s</code><span>, </span><code>after</code><span> is set to </span><code>""</code><span>, but </span><code>before</code><span> is set to </span><code>s</code><span> (that is, the whole string).</span>
<span>This is occasionally useful, and corresponds to the last Rust example.</span>
<span>But it also isn</span>&rsquo;<span>t something immediately obvious from the signature, it</span>&rsquo;<span>s an extra detail to keep in mind.</span>
<span>Which might be fine for a foundational function!</span>
<span>Similarly to Rust, the resulting strings point to the same memory as </span><code>s</code><span>.</span>
<span>There are no lifetimes, but a potential performance gotcha </span>&mdash;<span> if one of the resulting strings is alive, then the entire </span><code>s</code><span> can</span>&rsquo;<span>t be garbage collected.</span></p>
<p><span>There isn</span>&rsquo;<span>t much in way of using the function in Go:</span></p>

<figure class="code-block">


<pre><code><span class="line">prefix, suffix, ok = strings.Cut(line, <span class="hl-string">&quot;=&quot;</span>)</span>
<span class="line"><span class="hl-keyword">if</span> !ok {</span>
<span class="line">    ...</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Zig doesn</span>&rsquo;<span>t yet have an equivalent function in its standard library, but it probably will at some point, and the signature might look like this:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> cut</span>(</span>
<span class="line">    s: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span>,</span>
<span class="line">    sep: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span></span>
<span class="line">) ?<span class="hl-keyword">struct</span> { prefix: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span>, suffix: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span> } {</span>
<span class="line">    ...</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Similarly to Rust, Zig can express optional values.</span>
<span>Unlike Rust, the option is a built-in, rather than a user-defined type (Zig </span><em><span>can</span></em><span> express a generic user-defined option, but chooses not to).</span>
<span>All types in Zig are strictly prefix, so leading </span><code>?</code><span> concisely signals optionality.</span>
<span>Zig doesn</span>&rsquo;<span>t have first-class tuple types, but uses very concise and flexible type declaration syntax, so we can return a named tuple.</span>
<span>Curiously, this anonymous struct is still a nominal, rather than a structural, type!</span>
<span>Similarly to Rust, </span><code>prefix</code><span> and </span><code>suffix</code><span> borrow the same memory that </span><code>s</code><span> does.</span>
<span>Unlike Rust, this isn</span>&rsquo;<span>t expressed in the signature </span>&mdash;<span> while in this case it is obvious that the lifetime would be bound to </span><code>s</code><span>, rather than </span><code>sep</code><span>, there are no type system guardrails here.</span></p>
<p><span>Because </span><code>?</code><span> is a built-in type, we need some amount of special syntax to handle the result, but it curiously feels less special-case and more versatile than the Rust version.</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// Propagate `null` upwards / handle `null` in an ad-hoc way.</span></span>
<span class="line"><span class="hl-keyword">const</span> cut = mem.cut(line, <span class="hl-string">&quot;=&quot;</span>) <span class="hl-keyword">orelse</span> <span class="hl-keyword">return</span> <span class="hl-literal">null</span>;</span>
<span class="line"><span class="hl-keyword">const</span> cut = mem.cut(line, <span class="hl-string">&quot;=&quot;</span>) <span class="hl-keyword">orelse</span> <span class="hl-keyword">return</span>;</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Ignore or handle `null`.</span></span>
<span class="line"><span class="hl-keyword">if</span> (mem.cut(line, <span class="hl-string">&quot;=&quot;</span>)) <span class="hl-operator">|</span>cut<span class="hl-operator">|</span> {</span>
<span class="line"></span>
<span class="line">} <span class="hl-keyword">else</span> {</span>
<span class="line"></span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Go semantics: extract key with a default</span></span>
<span class="line">let key = <span class="hl-keyword">if</span> (mem.cut(line, <span class="hl-string">&quot;=&quot;</span>)) <span class="hl-operator">|</span>cut<span class="hl-operator">|</span> cut.first <span class="hl-keyword">else</span> line;</span></code></pre>

</figure>
<p><span>Moral of the story?</span>
<span>Work with the grain of the language </span>&mdash;<span> expressing the same concept in different languages usually requires a slightly different vocabulary.</span></p>
]]></content>
</entry>

<entry>
<title type="text">GitHub Merge Queue</title>
<link href="https://matklad.github.io/2023/06/18/GitHub-merge-queue.html" rel="alternate" type="text/html" title="GitHub Merge Queue" />
<published>2023-06-18T00:00:00+00:00</published>
<updated>2023-06-18T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/06/18/GitHub-merge-queue</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[Short, unedited note on GitHub merge queue.]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/06/18/GitHub-merge-queue.html"><![CDATA[
    <h1>
    <a href="#GitHub-Merge-Queue"><span>GitHub Merge Queue</span> <time datetime="2023-06-18">Jun 18, 2023</time></a>
    </h1>
<p><span>Short, unedited note on </span><a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue"><span>GitHub merge queue</span></a><span>.</span></p>
<p><span>TL;DR, </span><a href="https://bors.tech" class="url">https://bors.tech</a><span> delivers a meaningfully better experience, although it suffers from being a third-party integration.</span></p>
<p><span>Specific grievances:</span></p>
<p><em><span>Complexity</span></em><span>. This is a vague feeling, but merge queue feels like it is built by complexity merchants </span>&mdash;<span> there are a lot of unclear settings and voluminous and byzantine docs.</span>
<span>Good for allocating extra budget towards build engineering, bad for actual build engineering.</span></p>
<p><em><span>GUI-only configuration</span></em><span>. Bors is setup using bors.toml in the repository, merge queue is setup by clicking through web GUI.</span>
<span>To share config with other maintainers, I resorted to a zoomed-out screenshot of the page.</span></p>
<p><em><span>Unclear set of checks</span></em><span>. The purpose of the merge queue is to enforce not rocket science rule of software engineering </span>&mdash;<span> making sure that the code in the main branch satisfies certain quality invariants (all tests are passing).</span>
<span>It is impossible to tell what merge queue actually enforces.</span>
<span>Typically, when you enable merge queue, you subsequently find out that it actually merges anything, without any checks whatsoever.</span></p>
<p><em><span>Double latency</span></em><span>. One of the biggest benefits of a merge queue for a high velocity project is its </span><em><span>asynchrony</span></em><span>.</span>
<span>After submitting a PR, you can do a review and schedule PR to be merged </span><em><span>without</span></em><span> waiting for CI to finish.</span>
<span>This is massive: it is 2X reduction to human attention required.</span>
<span>Without queue, you need to look at a PR twice: once to do a review, and once to click merge after the green checkmark is in.</span>
<span>With the queue, you only need a review, and the green checkmark comes in asynchronously.</span>
<span>Except that with GitHub merge queue, you can</span>&rsquo;<span>t actually add a PR to the queue until you get a green checkmark.</span>
<span>In effect, that</span>&rsquo;<span>s still 2X attention, and then a PR runs through the same CI checks twice (yes, you can have separate checks for merge queue and PR. No, this is not a good idea, this is complexity and busywork).</span></p>
<p><em><span>Lack of delegation</span></em><span>. With bors, you can use </span><code>bors delegate+</code><span> to delegate merging of a single, specific pull request to its author.</span>
<span>This is helpful to drive contributor engagement, and to formalize </span>&ldquo;<span>LGTM with the nits fixed</span>&rdquo;<span> approval (which again reduces number of human round trips).</span></p>
<p><span>You still should use GitHub merge queue, rather than bors-ng, as that</span>&rsquo;<span>s now a first-party feature.</span>
<span>Still, its important to understand how things </span><em><span>should</span></em><span> work, to be able to improve state of the art some other time.</span></p>
]]></content>
</entry>

<entry>
<title type="text">The Worst Zig Version Manager</title>
<link href="https://matklad.github.io/2023/06/02/the-worst-zig-version-manager.html" rel="alternate" type="text/html" title="The Worst Zig Version Manager" />
<published>2023-06-02T00:00:00+00:00</published>
<updated>2023-06-02T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/06/02/the-worst-zig-version-manager</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[https://github.com/matklad/hello-getzig]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/06/02/the-worst-zig-version-manager.html"><![CDATA[
    <h1>
    <a href="#The-Worst-Zig-Version-Manager"><span>The Worst Zig Version Manager</span> <time datetime="2023-06-02">Jun 2, 2023</time></a>
    </h1>

<figure class="code-block">
<figcaption class="title">./getzig.ps1</figcaption>


<pre><code><span class="line">#!/bin/sh</span>
<span class="line">echo `# &lt;#`</span>
<span class="line"></span>
<span class="line">mkdir -p ./zig</span>
<span class="line"></span>
<span class="line">wget https://ziglang.org/download/0.10.1/zig-linux-x86_64-0.10.1.tar.xz -O ./zig/zig-linux-x86_64-0.10.1.tar.xz</span>
<span class="line">tar -xf ./zig/zig-linux-x86_64-0.10.1.tar.xz -C ./zig --strip-components=1</span>
<span class="line">rm ./zig/zig-linux-x86_64-0.10.1.tar.xz</span>
<span class="line"></span>
<span class="line">echo "Zig installed."</span>
<span class="line">./zig/zig version</span>
<span class="line"></span>
<span class="line">exit</span>
<span class="line">#&gt; &gt; $null</span>
<span class="line"></span>
<span class="line">Invoke-WebRequest -Uri "https://ziglang.org/download/0.10.1/zig-windows-x86_64-0.10.1.zip" -OutFile ".\zig-windows-x86_64-0.10.1.zip"</span>
<span class="line">Expand-Archive -Path ".\zig-windows-x86_64-0.10.1.zip" -DestinationPath ".\" -Force</span>
<span class="line">Remove-Item -Path " .\zig-windows-x86_64-0.10.1.zip"</span>
<span class="line">Rename-Item -Path ".\zig-windows-x86_64-0.10.1" -NewName ".\zig"</span>
<span class="line"></span>
<span class="line">Write-Host "Zig installed."</span>
<span class="line">./zig/zig.exe version</span></code></pre>

</figure>
<p class="display"><a href="https://github.com/matklad/hello-getzig" class="url">https://github.com/matklad/hello-getzig</a></p>
<p><span>Longer version:</span></p>
<p><span>One of the values of Zig which resonates with me deeply is a mindful approach to dependencies.</span>
<span>Zig tries hard not to ask too much from the environment, such that, if you get </span><code>zig version</code><span> running, you can be reasonably sure that everything else works.</span>
<span>That</span>&rsquo;<span>s one of the main motivations for adding an HTTP client to the Zig distribution recently.</span>
<span>Building software today involves downloading various components from the Internet, and, if Zig wants for software built with Zig to be hermetic and self-sufficient, it needs to provide ability to download files from HTTP servers.</span></p>
<p><span>There</span>&rsquo;<span>s one hurdle for self-sufficiency: how do you get Zig in the first place?</span>
<span>One answer to this question is </span>&ldquo;<span>from your distribution</span>&rsquo;<span>s package manager</span>&rdquo;<span>.</span>
<span>This is not a very satisfying answer, at least until the language is both post 1.0 and semi-frozen in development.</span>
<span>And even then, what if your distribution is Windows?</span>
<span>How many distributions should be covered by </span>&ldquo;<span>Installing Zig</span>&rdquo;<span> section of your </span><code>CONTRIBUTING.md</code><span>?</span></p>
<p><span>Another answer would be a version manager, a-la </span><code>rustup</code><span>, </span><code>nvm</code><span>, or </span><code>asdf</code><span>.</span>
<span>These tools work well, but they are quite complex, and rely on various subtle properties of the environment, like </span><code>PATH</code><span>, shell activation scripts and busybox-style multipurpose executable.</span>
<span>And, well, this also kicks the can down the road </span>&mdash;<span> you can use </span><code>zvm</code><span> to get Zig, but how do you get </span><code>zvm</code><span>?</span></p>
<p><span>I like how we do this in </span><a href="https://github.com/tigerbeetledb/tigerbeetle/blob/56d14e82769deb6817809f866253220ae0f499d1/scripts/install_zig.sh"><span>TigerBeetle</span></a><span>.</span>
<span>We don</span>&rsquo;<span>t use </span><code>zig</code><span> from </span><code>PATH</code><span>.</span>
<span>Instead, we just put the correct version of Zig into </span><code>./zig</code><span> folder in the root of the repository, and run it like this:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-title function_">$</span> ./zig/zig build test</span></code></pre>

</figure>
<p><span>Suddenly, whole swaths of complexity go away.</span>
<span>Quiz time: if you need to add a directory to </span><code>PATH</code><span>, which script should be edited so that both the graphical environment and the terminal are affected?</span></p>
<p><span>Finally, another interesting case study is Gradle.</span>
<span>Usually Gradle is a negative example, but they do have a good approach for installing Gradle itself.</span>
<span>The standard pattern is to store two scripts, </span><code>gradlew.sh</code><span> and </span><code>gradlew.bat</code><span>, which bootstrap the right version of Gradle by downloading a jar file (java itself is not bootstrapped this way though).</span></p>
<p><span>What all these approaches struggle to overcome is the problem of bootstrapping.</span>
<span>Generally, if you need to automate anything, you can write a program to do that.</span>
<span>But you need some pre-existing program runner!</span>
<span>And there</span>&rsquo;<span>s just no good options out of the box </span>&mdash;<span> bash and powershell are passable, but barely, and they are different.</span>
<span>And </span>&ldquo;<span>bash</span>&rdquo;<span> and the set of coreutils also differs depending on the Unix in question.</span>
<span>But there</span>&rsquo;<span>s just no good solution here </span>&mdash;<span> if you want to bootstrap automatically, you must start with universally available tools.</span></p>
<p><span>But is there perhaps some scripting language which is shared between Windows and Unix?</span>
<a href="https://github.com/cspotcode"><span>@cspotcode</span></a><span> suggests </span><a href="https://cspotcode.com/posts/polyglot-powershell-and-bash-script"><span>a horrible workaround</span></a><span>.</span>
<span>You can write a script which is </span><em><span>both</span></em><span> a bash script and a powershell script.</span>
<span>And it even isn</span>&rsquo;<span>t too too ugly!</span></p>

<figure class="code-block">


<pre><code><span class="line">!/bin/bash</span>
<span class="line">echo `# &lt;#`</span>
<span class="line"></span>
<span class="line">echo "Bash!"</span>
<span class="line"></span>
<span class="line">exit</span>
<span class="line">#&gt; &gt; $null</span>
<span class="line"></span>
<span class="line">Write-Host "PowerShell!"</span></code></pre>

</figure>
<p><span>So, here</span>&rsquo;<span>s an idea for a hermetic Zig version management workflow.</span>
<span>There</span>&rsquo;<span>s a canonical, short </span><code>getzig.ps1</code><span> PowerShell/sh script which is vendored verbatim by various projects.</span>
<span>Running this script downloads an appropriate version of Zig, and puts it into </span><code>./zig/zig</code><span> inside the repository (</span><code>.gitignore</code><span> contains </span><code>/zig</code><span>).</span>
<span>Building, testing, and other workflows use </span><code>./zig/zig</code><span> instead of relying on global system state (</span><code>$PATH</code><span>).</span></p>
<p><span>A proof-of-concept </span><code>getzig.ps1</code><span> is at the start of this article.</span>
<span>Note that I don</span>&rsquo;<span>t know bash, powershell, and how to download files from the Internet securely, so the above PoC was mostly written by Chat GPT.</span>
<span>But it seems to work on my machine.</span>
<span>I clone </span><a href="https://github.com/matklad/hello-getzig" class="url">https://github.com/matklad/hello-getzig</a><span> and run</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-title function_">$</span> ./getzig.ps1</span>
<span class="line"><span class="hl-title function_">$</span> ./zig/zig run ./hello.zig</span></code></pre>

</figure>
<p><span>on both NixOS and Windows 10, and it prints hello.</span></p>
<p><span>If anyone wants to make an actual thing out of this idea, here</span>&rsquo;<span>s possible desiderata:</span></p>
<ul>
<li>
<p><span>A single polyglot </span><code>getzig.sh.ps1</code><span> is cute, but using a couple of different scripts wouldn</span>&rsquo;<span>t be a big problem.</span></p>
</li>
<li>
<p><span>Size of the scripts </span><em><span>could</span></em><span> be a problem, as they are supposed to be vendored into each repository.</span>
<span>I</span>&rsquo;<span>d say 512 lines for combined </span><code>getzig.sh.ps1</code><span> would be a reasonable complexity limit.</span></p>
</li>
<li>
<p><span>The script must </span>&ldquo;<span>just work</span>&rdquo;<span> on all four major desktop operating systems: Linux, Mac, Windows, and WSL.</span></p>
</li>
<li>
<p><span>The script should be polymorphic in </span><code>curl</code><span> / </span><code>wget</code><span> and </span><code>bash</code><span> / </span><code>sh</code><span>.</span></p>
</li>
<li>
<p><span>It</span>&rsquo;<span>s ok if it doesn</span>&rsquo;<span>t work absolutely everywhere </span>&mdash;<span> downloading/building Zig manually for an odd platform is also an acceptable workflow.</span></p>
</li>
<li>
<p><span>The script should auto-detect appropriate host platform and architecture.</span></p>
</li>
<li>
<p><span>Zig version should be specified in a separate </span><code>zig-version.txt</code><span> file.</span></p>
</li>
<li>
<p><span>After downloading the file, its integrity should be verified.</span>
<span>For this reason, </span><code>zig-version.txt</code><span> should include a hash alongside the version.</span>
<span>As downloads are different depending on the platform, I think we</span>&rsquo;<span>ll need some help from Zig upstream here.</span>
<span>In particular, each published Zig version should include a cross-platform manifest file, which lists hashes and urls of per-platform binaries.</span>
<span>The hash included into </span><code>zig-version.txt</code><span> should be the manifest</span>&rsquo;<span>s hash.</span></p>
</li>
</ul>
]]></content>
</entry>

<entry>
<title type="text">Resilient LL Parsing Tutorial</title>
<link href="https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html" rel="alternate" type="text/html" title="Resilient LL Parsing Tutorial" />
<published>2023-05-21T00:00:00+00:00</published>
<updated>2023-05-21T00:00:00+00:00</updated>
<id>https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial</id>
<author><name>Alex Kladov</name></author>
<summary type="html"><![CDATA[In this tutorial, I will explain a particular approach to parsing, which gracefully handles syntax errors and is thus suitable for language servers, which, by their nature, have to handle incomplete and invalid code.
Explaining the problem and the solution requires somewhat less than a trivial worked example, and I want to share a couple of tricks not directly related to resilience, so the tutorial builds a full, self-contained parser, instead of explaining abstractly just the resilience.]]></summary>
<content type="html" xml:base="https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html"><![CDATA[
    <h1>
    <a href="#Resilient-LL-Parsing-Tutorial"><span>Resilient LL Parsing Tutorial</span> <time datetime="2023-05-21">May 21, 2023</time></a>
    </h1>
<p><span>In this tutorial, I will explain a particular approach to parsing, which gracefully handles syntax errors and is thus suitable for language servers, which, by their nature, have to handle incomplete and invalid code.</span>
<span>Explaining the problem and the solution requires somewhat less than a trivial worked example, and I want to share a couple of tricks not directly related to resilience, so the tutorial builds a full, self-contained parser, instead of explaining abstractly </span><em><span>just</span></em><span> the resilience.</span></p>
<p><span>The tutorial is descriptive, rather than prescriptive </span>&mdash;<span> it tells you what you </span><em><span>can</span></em><span> do, not what you </span><em><span>should</span></em><span> do.</span></p>
<ul>
<li>
<span>If you are looking into building a production grade language server, treat it as a library of ideas, not as a blueprint.</span>
</li>
<li>
<span>If you want to get something working quickly, I think today the best answer is </span>&ldquo;<span>just use </span><a href="https://tree-sitter.github.io"><span>Tree-sitter</span></a>&rdquo;<span>, so you</span>&rsquo;<span>d better read its docs rather than this tutorial.</span>
</li>
<li>
<span>If you are building an IDE-grade parser from scratch, then techniques presented here might be directly applicable.</span>
</li>
</ul>
<section id="Why-Resilience-is-Needed">

    <h2>
    <a href="#Why-Resilience-is-Needed"><span>Why Resilience is Needed?</span> </a>
    </h2>
<p><span>Let</span>&rsquo;<span>s look at one motivational example for resilient parsing:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">fib_rec</span>(f1: <span class="hl-type">u32</span>,</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">fib</span>(n: <span class="hl-type">u32</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">u32</span> {</span>
<span class="line">  <span class="hl-title function_ invoke__">fib_rec</span>(<span class="hl-number">1</span>, <span class="hl-number">1</span>, n)</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Here, a user is in the process of defining the </span><code>fib_rec</code><span> helper function.</span>
<span>For a language server, it</span>&rsquo;<span>s important that the incompleteness doesn</span>&rsquo;<span>t get in the way.</span>
<span>In particular:</span></p>
<ul>
<li>
<p><span>The following function, </span><code>fib</code><span>, should be parsed without any errors such that syntax and semantic highlighting is not disturbed, and all calls to </span><code>fib</code><span> elsewhere typecheck correctly.</span></p>
</li>
<li>
<p><span>The </span><code>fib_rec</code><span> function itself should be recognized as a partially complete function, so that various language server assists can help complete it correctly.</span></p>
</li>
<li>
<p><span>In particular, a smart language server can actually infer the expected type of </span><code>fib_rec</code><span> from a call we already have, and suggest completing the whole prototype.</span>
<span>rust-analyzer doesn</span>&rsquo;<span>t do that today, but one day it should.</span></p>
</li>
</ul>
<p><span>Generalizing this example, what we want from our parser is to recognize as much of the syntactic structure as feasible.</span>
<span>It should be able to localize errors </span>&mdash;<span> a mistake in a function generally should not interfere with parsing unrelated functions.</span>
<span>As the code is read and written left-to-right, the parser should also recognize valid partial prefixes of various syntactic constructs.</span></p>
<p><span>Academic literature suggests another lens to use when looking at this problem: error recovery.</span>
<span>Rather than just recognizing incomplete constructs, the parser can attempt to guess a minimal edit which completes the construct and gets rid of the syntax error.</span>
<span>From this angle, the above example would look rather like </span><span class="display"><code>fn fib_rec(f1: u32, /* ) {} */</code><span> ,</span></span><span> where the stuff in a comment is automatically inserted by the parser.</span></p>
<p><span>Resilience is a more fruitful framing to use for a language server </span>&mdash;<span> incomplete code is the ground truth, and only the user knows how to correctly complete it.</span>
<span>An language server can only offer guesses and suggestions, and they are more precise if they employ post-parsing semantic information.</span></p>
<p><span>Error recovery might work better when emitting understandable syntax errors, but, in a language server, the importance of clear error messages for </span><em><span>syntax</span></em><span> errors is relatively lower, as highlighting such errors right in the editor synchronously with typing usually provides tighter, more useful tacit feedback.</span></p>
</section>
<section id="Approaches-to-Error-Resilience">

    <h2>
    <a href="#Approaches-to-Error-Resilience"><span>Approaches to Error Resilience</span> </a>
    </h2>
<p><span>The classic approach for handling parser errors is to explicitly encode error productions and synchronization tokens into the language grammar.</span>
<span>This approach isn</span>&rsquo;<span>t a natural fit for resilience framing </span>&mdash;<span> you don</span>&rsquo;<span>t want to anticipate every possible error, as there are just too many possibilities.</span>
<span>Rather, you want to recover as much of a valid syntax tree as possible, and more or less ignore arbitrary invalid parts.</span></p>
<p><span>Tree-sitter does something more interesting.</span>
<span>It is a </span><strong><strong><span>G</span></strong></strong><span>LR parser, meaning that it non-deterministically tries many possible LR (bottom-up) parses, and looks for the best one.</span>
<span>This allows Tree-sitter to recognize many complete valid small fragments of a tree, but it might have trouble assembling them into incomplete larger fragments.</span>
<span>In our example </span><span class="display"><code>fn fib_rec(f1: u32,</code><span> ,</span></span><span> Tree-sitter correctly recognizes </span><code>f1: u32</code><span> as a formal parameter, but doesn</span>&rsquo;<span>t recognize </span><code>fib_rec</code><span> as a function.</span></p>
<p><span>Top-down (LL) parsing paradigm makes it harder to recognize valid small fragments, but naturally allows for incomplete large nodes.</span>
<span>Because code is written top-down and left-to-right, LL seems to have an advantage for typical patterns of incomplete code.</span>
<span>Moreover, there isn</span>&rsquo;<span>t really anything special you need to do to make LL parsing resilient.</span>
<span>You sort of</span>&hellip;<span> just not crash on the first error, and everything else more or less just works.</span></p>
<p><span>Details are fiddly though, so, in the rest of the post, we will write a complete implementation of a hand-written recursive descent + Pratt resilient parser.</span></p>
</section>
<section id="Introducing-L">

    <h2>
    <a href="#Introducing-L"><span>Introducing L</span> </a>
    </h2>
<p><span>For the lack of imagination on my side, the toy language we will be parsing is called </span><code>L</code><span>.</span>
<span>It is a subset of Rust, which has just enough features to make some syntax mistakes.</span>
<span>Here</span>&rsquo;<span>s Fibonacci:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">fib</span>(n: <span class="hl-type">u32</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">u32</span> {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">f1</span> = <span class="hl-title function_ invoke__">fib</span>(n - <span class="hl-number">1</span>);</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">f2</span> = <span class="hl-title function_ invoke__">fib</span>(n - <span class="hl-number">2</span>);</span>
<span class="line">    <span class="hl-keyword">return</span> f1 + f2;</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Note that there</span>&rsquo;<span>s no base case, because L doesn</span>&rsquo;<span>t have syntax for </span><code>if</code><span>.</span>
<span>Here</span>&rsquo;<span>s the syntax it does have, as an </span><a href="https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html"><span>ungrammar</span></a><span>:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-literal">File</span> = Fn*</span>
<span class="line"></span>
<span class="line"><span class="hl-literal">Fn</span> = <span class="hl-string">&#x27;fn&#x27;</span> <span class="hl-string">&#x27;name&#x27;</span> ParamList (<span class="hl-string">&#x27;-&gt;&#x27;</span> TypeExpr)? Block</span>
<span class="line"></span>
<span class="line"><span class="hl-literal">ParamList</span> = <span class="hl-string">&#x27;(&#x27;</span> Param* <span class="hl-string">&#x27;)&#x27;</span></span>
<span class="line"><span class="hl-literal">Param</span> = <span class="hl-string">&#x27;name&#x27;</span> <span class="hl-string">&#x27;:&#x27;</span> TypeExpr <span class="hl-string">&#x27;,&#x27;</span>?</span>
<span class="line"></span>
<span class="line"><span class="hl-literal">TypeExpr</span> = <span class="hl-string">&#x27;name&#x27;</span></span>
<span class="line"></span>
<span class="line"><span class="hl-literal">Block</span> = <span class="hl-string">&#x27;{&#x27;</span> Stmt* <span class="hl-string">&#x27;}&#x27;</span></span>
<span class="line"></span>
<span class="line"><span class="hl-literal">Stmt</span> =</span>
<span class="line">  StmtExpr</span>
<span class="line">| StmtLet</span>
<span class="line">| StmtReturn</span>
<span class="line"></span>
<span class="line"><span class="hl-literal">StmtExpr</span> = Expr <span class="hl-string">&#x27;;&#x27;</span></span>
<span class="line"><span class="hl-literal">StmtLet</span> = <span class="hl-string">&#x27;let&#x27;</span> <span class="hl-string">&#x27;name&#x27;</span> <span class="hl-string">&#x27;=&#x27;</span> Expr <span class="hl-string">&#x27;;&#x27;</span></span>
<span class="line"><span class="hl-literal">StmtReturn</span> = <span class="hl-string">&#x27;return&#x27;</span> Expr <span class="hl-string">&#x27;;&#x27;</span></span>
<span class="line"></span>
<span class="line"><span class="hl-literal">Expr</span> =</span>
<span class="line">  ExprLiteral</span>
<span class="line">| ExprName</span>
<span class="line">| ExprParen</span>
<span class="line">| ExprBinary</span>
<span class="line">| ExprCall</span>
<span class="line"></span>
<span class="line"><span class="hl-literal">ExprLiteral</span> = <span class="hl-string">&#x27;int&#x27;</span> | <span class="hl-string">&#x27;true&#x27;</span> | <span class="hl-string">&#x27;false&#x27;</span></span>
<span class="line"><span class="hl-literal">ExprName</span> = <span class="hl-string">&#x27;name&#x27;</span></span>
<span class="line"><span class="hl-literal">ExprParen</span> = <span class="hl-string">&#x27;(&#x27;</span> Expr <span class="hl-string">&#x27;)&#x27;</span></span>
<span class="line"><span class="hl-literal">ExprBinary</span> = Expr (<span class="hl-string">&#x27;+&#x27;</span> | <span class="hl-string">&#x27;-&#x27;</span> | <span class="hl-string">&#x27;*&#x27;</span> | <span class="hl-string">&#x27;/&#x27;</span>) Expr</span>
<span class="line"><span class="hl-literal">ExprCall</span> = Expr ArgList</span>
<span class="line"></span>
<span class="line"><span class="hl-literal">ArgList</span> = <span class="hl-string">&#x27;(&#x27;</span> Arg* <span class="hl-string">&#x27;)&#x27;</span></span>
<span class="line"><span class="hl-literal">Arg</span> = Expr <span class="hl-string">&#x27;,&#x27;</span>?</span></code></pre>

</figure>
<p><span>The meta syntax here is similar to BNF, with two important differences:</span></p>
<ul>
<li>
<span>the notation is better specified and more familiar (recursive regular expressions),</span>
</li>
<li>
<span>it describes syntax </span><em><span>trees</span></em><span>, rather than strings (</span><em><span>sequences</span></em><span> of tokens).</span>
</li>
</ul>
<p><span>Single quotes signify terminals: </span><code>'fn'</code><span> and </span><code>'return'</code><span> are keywords, </span><code>'name'</code><span> stands for any identifier token, like </span><code>foo</code><span>, and </span><code>'('</code><span> is punctuation.</span>
<span>Unquoted names are non-terminals. For example, </span><code>x: i32,</code><span> would be an example of </span><code>Param</code><span>.</span>
<span>Unquoted punctuation are meta symbols of ungrammar itself, semantics identical to regular expressions. Zero or more repetition is </span><code>*</code><span>, zero or one is </span><code>?</code><span>, </span><code>|</code><span> is alternation and </span><code>()</code><span> are used for grouping.</span></p>
<p><span>The grammar doesn</span>&rsquo;<span>t nail the syntax precisely. For example, the rule for </span><code>Param</code><span>, </span><span class="display"><code>Param = 'name' ':' Type ','?</code><span> ,</span></span><span> says that </span><code>Param</code><span> syntax node has an optional comma, but there</span>&rsquo;<span>s nothing in the above </span><code>ungrammar</code><span> specifying whether the trailing commas are allowed.</span></p>
<p><span>Overall, </span><code>L</code><span> has very little to it </span>&mdash;<span> a program is a series of function declarations, each function has a body which is a sequence of statements, the set of expressions is spartan, not even an </span><code>if</code><span>. Still, it</span>&rsquo;<span>ll take us some time to parse all that.</span>
<span>But you can already try the end result in the text-box below.</span>
<span>The syntax tree is updated automatically on typing.</span>
<span>Do make mistakes to see how a partial tree is recovered.</span></p>
<aside id="playground" style="min-height: 400px; min-width: 400px; ; display: flex; flex-direction: row;">
<textarea class="input"  style="height: 400px; width: 50%; margin: 2px; padding: 2px; resize: none;">
fn fib_rec(f1: u32,

fn fib(n: u32) -> u32 {
  fib_rec(1, 1, n)
}
</textarea>
<textarea class="output" style="height: 400px; width: 50%; margin: 2px; padding: 2px; resize: none;" readonly=true>
</textarea>
</aside>
</section>
<section id="Designing-the-Tree">

    <h2>
    <a href="#Designing-the-Tree"><span>Designing the Tree</span> </a>
    </h2>
<p><span>A traditional AST for L might look roughly like this:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">File</span> {</span>
<span class="line">  functions: <span class="hl-type">Vec</span>&lt;Function&gt;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Function</span> {</span>
<span class="line">  name: <span class="hl-type">String</span>,</span>
<span class="line">  params: <span class="hl-type">Vec</span>&lt;Param&gt;,</span>
<span class="line">  return_type: <span class="hl-type">Option</span>&lt;TypeExpr&gt;,</span>
<span class="line">  block: Block,</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Extending this structure to be resilient is non-trivial. There are two problems: trivia and errors.</span></p>
<p><span>For resilient parsing, we want the AST to contain every detail about the source text.</span>
<span>We actually don</span>&rsquo;<span>t want to use an </span><em><span>abstract</span></em><span> syntax tree, and need a </span><em><span>concrete</span></em><span> one.</span>
<span>In a traditional AST, the tree structure is rigidly defined </span>&mdash;<span> any syntax node has a fixed number of children.</span>
<span>But there can be any number of comments and whitespace anywhere in the tree, and making space for them in the structure requires some fiddly data manipulation.</span>
<span>Similarly, errors (e.g., unexpected tokens), can appear anywhere in the tree.</span></p>
<p><span>One trick to handle these in the AST paradigm is to attach trivia and error tokens to other tokens.</span>
<span>That is, for something like</span>
<span class="display"><code>fn /* name of the function -&gt; */ f() {}</code><span> ,</span></span>
<span>the </span><code>fn</code><span> and </span><code>f</code><span> tokens would be explicit parts of the AST, while the comment and surrounding whitespace would belong to the collection of trivia tokens hanging off the </span><code>fn</code><span> token.</span></p>
<p><span>One complication here is that it</span>&rsquo;<span>s not always just tokens that can appear anywhere, sometimes you can have full trees like that.</span>
<span>For example, comments might support markdown syntax, and you might actually want to parse that properly (e.g., to resolve links to declarations).</span>
<span>Syntax errors can also span whole subtrees.</span>
<span>For example, when parsing </span><code>pub(crate) nope</code><span> in Rust, it would be smart to parse </span><code>pub(crate)</code><span> as a visibility modifier, and nest it into a bigger </span><code>Error</code><span> node.</span></p>
<p><span>SwiftSyntax meticulously adds error placeholders between any two fields of an AST node, giving rise to</span>
<span class="display"><code>unexpectedBetweenModifiersAndDeinitKeyword</code></span>
<span>and such (</span><a href="https://github.com/apple/swift-syntax/blob/66450960b1ed88b842d63f7a38254aaba08bbd4d/Sources/SwiftSyntax/generated/syntaxNodes/SyntaxDeclNodes.swift#L1368"><span>source</span></a><span>, </span><a href="https://swiftpackageindex.com/apple/swift-syntax/508.0.1/documentation/swiftsyntax/classdeclsyntax#instance-properties"><span>docs</span></a><span>).</span></p>
<p><span>An alternative approach, used by IntelliJ and rust-analyzer, is to treat the syntax tree as a somewhat dynamically-typed data structure:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">enum</span> <span class="hl-title class_">TokenKind</span> {</span>
<span class="line">  ErrorToken, LParen, RParen, <span class="hl-built_in">Eq</span>,</span>
<span class="line">  ...</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Token</span> {</span>
<span class="line">  kind: TokenKind,</span>
<span class="line">  text: <span class="hl-type">String</span>,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">enum</span> <span class="hl-title class_">TreeKind</span> {</span>
<span class="line">  ErrorTree, File, <span class="hl-built_in">Fn</span>, Param,</span>
<span class="line">  ...</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Tree</span> {</span>
<span class="line">  kind: TreeKind,</span>
<span class="line">  children: <span class="hl-type">Vec</span>&lt;Child&gt;,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">enum</span> <span class="hl-title class_">Child</span> {</span>
<span class="line">  <span class="hl-title function_ invoke__">Token</span>(Token),</span>
<span class="line">  <span class="hl-title function_ invoke__">Tree</span>(Tree),</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>This structure does not enforce any constraints on the shape of the syntax tree at all, and so it naturally accommodates errors anywhere.</span>
<span>It is possible to layer a well-typed API on top of this dynamic foundation.</span>
<span>An extra benefit of this representation is that you can use the same tree </span><em><span>type</span></em><span> for different languages; this is a requirement for universal tools.</span></p>
<p><span>Discussing specifics of syntax tree representation goes beyond this article, as the topic is vast and lacks a clear winning solution.</span>
<span>To learn about it, take a look at Roslyn, SwiftSyntax, rowan and IntelliJ.</span></p>
<p><span>To simplify things, we</span>&rsquo;<span>ll ignore comments and whitespace, though you</span>&rsquo;<span>ll absolutely want those in a real implementation.</span>
<span>One approach would be to do the parsing without comments, like we do here, and then attach comments to the nodes in a separate pass.</span>
<span>Attaching comments needs some heuristics </span>&mdash;<span> for example, non-doc comments generally want to be a part of the following syntax node.</span></p>
<p><span>Another design choice is handling of error messages.</span>
<span>One approach is to treat error messages as properties of the syntax tree itself, by either inferring them from the tree structure, or just storing them inline.</span>
<span>Alternatively, errors can be considered to be a side-effect of the parsing process (that way, trees constructed manually during, eg, refactors, won</span>&rsquo;<span>t carry any error messages, even if they are invalid).</span></p>
<p><span>Here</span>&rsquo;<span>s the full set of token and tree kinds for our language L:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">enum</span> <span class="hl-title class_">TokenKind</span> {</span>
<span class="line">  ErrorToken, Eof,</span>
<span class="line"></span>
<span class="line">  LParen, RParen, LCurly, RCurly,</span>
<span class="line">  <span class="hl-built_in">Eq</span>, Semi, Comma, Colon, Arrow,</span>
<span class="line">  Plus, Minus, Star, Slash,</span>
<span class="line"></span>
<span class="line">  FnKeyword, LetKeyword, ReturnKeyword,</span>
<span class="line">  TrueKeyword, FalseKeyword,</span>
<span class="line"></span>
<span class="line">  Name, Int,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">enum</span> <span class="hl-title class_">TreeKind</span> {</span>
<span class="line">  ErrorTree,</span>
<span class="line">  File, <span class="hl-built_in">Fn</span>, TypeExpr,</span>
<span class="line">  ParamList, Param,</span>
<span class="line">  Block,</span>
<span class="line">  StmtLet, StmtReturn, StmtExpr,</span>
<span class="line">  ExprLiteral, ExprName, ExprParen,</span>
<span class="line">  ExprBinary, ExprCall,</span>
<span class="line">  ArgList, Arg,</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Things to note:</span></p>
<ul>
<li>
<span>explicit </span><code>Error</code><span> kinds;</span>
</li>
<li>
<span>no whitespace or comments, as an unrealistic simplification;</span>
</li>
<li>
<code>Eof</code><span> virtual token simplifies parsing, removing the need to handle </span><code>Option&lt;Token&gt;</code><span>;</span>
</li>
<li>
<span>punctuators are named after what they are, rather than after what they usually mean: </span><code>Star</code><span>, rather than </span><code>Mult</code><span>;</span>
</li>
<li>
<span>a good set of name for various kinds of braces is </span><span class="display"><code>{L,R}{Paren,Curly,Brack,Angle}</code><span>.</span></span>
</li>
</ul>
</section>
<section id="Lexer">

    <h2>
    <a href="#Lexer"><span>Lexer</span> </a>
    </h2>
<p><span>Won</span>&rsquo;<span>t be covering lexer here, let</span>&rsquo;<span>s just say we have </span><span class="display"><code>fn lex(text: &amp;str) -&gt; Vec&lt;Token&gt;</code><span>,</span></span><span> function. Two points worth mentioning:</span></p>
<ul>
<li>
<span>Lexer itself should be resilient, but that</span>&rsquo;<span>s easy </span>&mdash;<span> produce an </span><code>Error</code><span> token for anything which isn</span>&rsquo;<span>t a valid token.</span>
</li>
<li>
<span>Writing lexer by hand is somewhat tedious, but is very simple relative to everything else.</span>
<span>If you are stuck in an analysis-paralysis picking a lexer generator, consider cutting the Gordian knot and hand-writing.</span>
</li>
</ul>
</section>
<section id="Parser">

    <h2>
    <a href="#Parser"><span>Parser</span> </a>
    </h2>
<p><span>With homogenous syntax trees, the task of parsing admits an elegant formalization </span>&mdash;<span> we want to insert extra parenthesis into a stream of tokens.</span></p>

<figure class="code-block">


<pre><code><span class="line">+-Fun</span>
<span class="line">|      +-Param</span>
<span class="line">|      |</span>
<span class="line">[fn f( [x: Int] ) {}]</span>
<span class="line">     |            |</span>
<span class="line">     |            +-Block</span>
<span class="line">     +-ParamList</span></code></pre>

</figure>
<p><span>Note how the sequence of tokens with extra parenthesis is still a flat sequence.</span>
<span>The parsing will be two-phase:</span></p>
<ul>
<li>
<span>in the first phase, the parser emits a flat list of events,</span>
</li>
<li>
<span>in the second phase, the list is converted to a tree.</span>
</li>
</ul>
<p><span>Here</span>&rsquo;<span>s the basic setup for the parser:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">enum</span> <span class="hl-title class_">Event</span> {</span>
<span class="line">  Open { kind: TreeKind }, <i class="callout" data-value="2"></i></span>
<span class="line">  Close,</span>
<span class="line">  Advance,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">MarkOpened</span> {</span>
<span class="line">  index: <span class="hl-type">usize</span>,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Parser</span> {</span>
<span class="line">  tokens: <span class="hl-type">Vec</span>&lt;Token&gt;,</span>
<span class="line">  pos: <span class="hl-type">usize</span>,</span>
<span class="line">  fuel: Cell&lt;<span class="hl-type">u32</span>&gt;, <i class="callout" data-value="4"></i></span>
<span class="line">  events: <span class="hl-type">Vec</span>&lt;Event&gt;,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">impl</span> <span class="hl-title class_">Parser</span> {</span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">open</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> MarkOpened { <i class="callout" data-value="1"></i></span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">mark</span> = MarkOpened { index: <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">len</span>() };</span>
<span class="line">    <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">push</span>(Event::Open { kind: TreeKind::ErrorTree });</span>
<span class="line">    mark</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">close</span>(  <i class="callout" data-value="1"></i></span>
<span class="line">    &amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>,</span>
<span class="line">    m: MarkOpened,</span>
<span class="line">    kind: TreeKind, <i class="callout" data-value="2"></i></span>
<span class="line">  ) {</span>
<span class="line">    <span class="hl-keyword">self</span>.events[m.index] = Event::Open { kind };</span>
<span class="line">    <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">push</span>(Event::Close);</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">advance</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>) { <i class="callout" data-value="1"></i></span>
<span class="line">    <span class="hl-built_in">assert!</span>(!<span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">eof</span>());</span>
<span class="line">    <span class="hl-keyword">self</span>.fuel.<span class="hl-title function_ invoke__">set</span>(<span class="hl-number">256</span>); <i class="callout" data-value="4"></i></span>
<span class="line">    <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">push</span>(Event::Advance);</span>
<span class="line">    <span class="hl-keyword">self</span>.pos += <span class="hl-number">1</span>;</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">eof</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">bool</span> {</span>
<span class="line">    <span class="hl-keyword">self</span>.pos == <span class="hl-keyword">self</span>.tokens.<span class="hl-title function_ invoke__">len</span>()</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">nth</span>(&amp;<span class="hl-keyword">self</span>, lookahead: <span class="hl-type">usize</span>) <span class="hl-punctuation">-&gt;</span> TokenKind { <i class="callout" data-value="3"></i></span>
<span class="line">    <span class="hl-keyword">if</span> <span class="hl-keyword">self</span>.fuel.<span class="hl-title function_ invoke__">get</span>() == <span class="hl-number">0</span> { <i class="callout" data-value="4"></i></span>
<span class="line">      <span class="hl-built_in">panic!</span>(<span class="hl-string">&quot;parser is stuck&quot;</span>)</span>
<span class="line">    }</span>
<span class="line">    <span class="hl-keyword">self</span>.fuel.<span class="hl-title function_ invoke__">set</span>(<span class="hl-keyword">self</span>.fuel.<span class="hl-title function_ invoke__">get</span>() - <span class="hl-number">1</span>);</span>
<span class="line">    <span class="hl-keyword">self</span>.tokens.<span class="hl-title function_ invoke__">get</span>(<span class="hl-keyword">self</span>.pos + lookahead)</span>
<span class="line">      .<span class="hl-title function_ invoke__">map_or</span>(TokenKind::Eof, |it| it.kind)</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">at</span>(&amp;<span class="hl-keyword">self</span>, kind: TokenKind) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">bool</span> { <i class="callout" data-value="3"></i></span>
<span class="line">    <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">nth</span>(<span class="hl-number">0</span>) == kind</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">eat</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>, kind: TokenKind) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">bool</span> { <i class="callout" data-value="3"></i></span>
<span class="line">    <span class="hl-keyword">if</span> <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">at</span>(kind) {</span>
<span class="line">      <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">      <span class="hl-literal">true</span></span>
<span class="line">    } <span class="hl-keyword">else</span> {</span>
<span class="line">      <span class="hl-literal">false</span></span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">expect</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>, kind: TokenKind) {</span>
<span class="line">    <span class="hl-keyword">if</span> <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">eat</span>(kind) {</span>
<span class="line">      <span class="hl-keyword">return</span>;</span>
<span class="line">    }</span>
<span class="line">    <span class="hl-comment">// <span class="hl-doctag">TODO:</span> Error reporting.</span></span>
<span class="line">    eprintln!(<span class="hl-string">&quot;expected {kind:?}&quot;</span>);</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">advance_with_error</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>, error: &amp;<span class="hl-type">str</span>) {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line">    <span class="hl-comment">// <span class="hl-doctag">TODO:</span> Error reporting.</span></span>
<span class="line">    eprintln!(<span class="hl-string">&quot;{error}&quot;</span>);</span>
<span class="line">    <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">    <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">close</span>(m, ErrorTree);</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<p><code>open</code><span>, </span><code>advance</code><span>, and </span><code>close</code><span> form the basis for constructing the stream of events.</span></p>
</li>
<li>
<p><span>Note how </span><code>kind</code><span> is stored in the </span><code>Open</code><span> event, but is supplied with the </span><code>close</code><span> method.</span>
<span>This is required for flexibility </span>&mdash;<span> sometimes it</span>&rsquo;<span>s possible to decide on the type of syntax node only after it is parsed.</span>
<span>The way this works is that the </span><code>open</code><span> method returns a </span><code>Mark</code><span> which is subsequently passed to </span><code>close</code><span> to modify the corresponding </span><code>Open</code><span> event.</span></p>
</li>
<li>
<p><span>There</span>&rsquo;<span>s a set of short, convenient methods to navigate through the sequence of tokens:</span></p>
<ul>
<li>
<code>nth</code><span> is the lookahead method. Note how it doesn</span>&rsquo;<span>t return an </span><code>Option</code><span>, and uses </span><code>Eof</code><span> special value for </span>&ldquo;<span>out of bounds</span>&rdquo;<span> indexes.</span>
<span>This simplifies the call-site, </span>&ldquo;<span>no more tokens</span>&rdquo;<span> and </span>&ldquo;<span>token of a wrong kind</span>&rdquo;<span> are always handled the same.</span>
</li>
<li>
<code>at</code><span> is a convenient specialization to check for a specific next token.</span>
</li>
<li>
<code>eat</code><span> is </span><code>at</code><span> combined with consuming the next token.</span>
</li>
<li>
<code>expect</code><span> is </span><code>eat</code><span> combined with error reporting.</span>
</li>
</ul>
<p><span>These methods are not a very orthogonal basis, but they are a convenience basis for parsing.</span>
<span>Finally, </span><code>advance_with_error</code><span> advanced over any token, but also wraps it into an error node.</span></p>
</li>
<li>
<p><span>When writing parsers by hand, it</span>&rsquo;<span>s very easy to accidentally write the code which loops or recurses forever.</span>
<span>To simplify debugging, it</span>&rsquo;<span>s helpful to add an explicit notion of </span>&ldquo;<span>fuel</span>&rdquo;<span>, which is replenished every time the parser makes progress,</span>
<span>and is spent every time it does not.</span></p>
</li>
</ol>
<p><span>The function to transform a flat list of events into a tree is a bit involved.</span>
<span>It juggles three things: an iterator of events, an iterator of tokens, and a stack of partially constructed nodes (we expect the stack to contain just one node at the end).</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">impl</span> <span class="hl-title class_">Parser</span> {</span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">build_tree</span>(<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> Tree {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">tokens</span> = <span class="hl-keyword">self</span>.tokens.<span class="hl-title function_ invoke__">into_iter</span>();</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">events</span> = <span class="hl-keyword">self</span>.events;</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">stack</span> = <span class="hl-type">Vec</span>::<span class="hl-title function_ invoke__">new</span>();</span>
<span class="line"></span>
<span class="line">    <span class="hl-comment">// Special case: pop the last `Close` event to ensure</span></span>
<span class="line">    <span class="hl-comment">// that the stack is non-empty inside the loop.</span></span>
<span class="line">    <span class="hl-built_in">assert!</span>(matches!(events.<span class="hl-title function_ invoke__">pop</span>(), <span class="hl-title function_ invoke__">Some</span>(Event::Close)));</span>
<span class="line"></span>
<span class="line">    <span class="hl-keyword">for</span> <span class="hl-variable">event</span> <span class="hl-keyword">in</span> events {</span>
<span class="line">      <span class="hl-keyword">match</span> event {</span>
<span class="line">        <span class="hl-comment">// Starting a new node; just push an empty tree to the stack.</span></span>
<span class="line">        Event::Open { kind } =&gt; {</span>
<span class="line">          stack.<span class="hl-title function_ invoke__">push</span>(Tree { kind, children: <span class="hl-type">Vec</span>::<span class="hl-title function_ invoke__">new</span>() })</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        <span class="hl-comment">// A tree is done.</span></span>
<span class="line">        <span class="hl-comment">// Pop it off the stack and append to a new current tree.</span></span>
<span class="line">        Event::Close =&gt; {</span>
<span class="line">          <span class="hl-keyword">let</span> <span class="hl-variable">tree</span> = stack.<span class="hl-title function_ invoke__">pop</span>().<span class="hl-title function_ invoke__">unwrap</span>();</span>
<span class="line">          stack</span>
<span class="line">            .<span class="hl-title function_ invoke__">last_mut</span>()</span>
<span class="line">            <span class="hl-comment">// If we don&#x27;t pop the last `Close` before this loop,</span></span>
<span class="line">            <span class="hl-comment">// this unwrap would trigger for it.</span></span>
<span class="line">            .<span class="hl-title function_ invoke__">unwrap</span>()</span>
<span class="line">            .children</span>
<span class="line">            .<span class="hl-title function_ invoke__">push</span>(Child::<span class="hl-title function_ invoke__">Tree</span>(tree));</span>
<span class="line">        }</span>
<span class="line"></span>
<span class="line">        <span class="hl-comment">// Consume a token and append it to the current tree</span></span>
<span class="line">        Event::Advance =&gt; {</span>
<span class="line">          <span class="hl-keyword">let</span> <span class="hl-variable">token</span> = tokens.<span class="hl-title function_ invoke__">next</span>().<span class="hl-title function_ invoke__">unwrap</span>();</span>
<span class="line">          stack</span>
<span class="line">            .<span class="hl-title function_ invoke__">last_mut</span>()</span>
<span class="line">            .<span class="hl-title function_ invoke__">unwrap</span>()</span>
<span class="line">            .children</span>
<span class="line">            .<span class="hl-title function_ invoke__">push</span>(Child::<span class="hl-title function_ invoke__">Token</span>(token));</span>
<span class="line">        }</span>
<span class="line">      }</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hl-comment">// Our parser will guarantee that all the trees are closed</span></span>
<span class="line">    <span class="hl-comment">// and cover the entirety of tokens.</span></span>
<span class="line">    <span class="hl-built_in">assert!</span>(stack.<span class="hl-title function_ invoke__">len</span>() == <span class="hl-number">1</span>);</span>
<span class="line">    <span class="hl-built_in">assert!</span>(tokens.<span class="hl-title function_ invoke__">next</span>().<span class="hl-title function_ invoke__">is_none</span>());</span>
<span class="line"></span>
<span class="line">    stack.<span class="hl-title function_ invoke__">pop</span>().<span class="hl-title function_ invoke__">unwrap</span>()</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
</section>
<section id="Grammar">

    <h2>
    <a href="#Grammar"><span>Grammar</span> </a>
    </h2>
<p><span>We are finally getting to the actual topic of resilient parser.</span>
<span>Now we will write a full grammar for L as a sequence of functions.</span>
<span>Usually both atomic parser operations, like </span><code>fn advance</code><span>, and grammar productions, like </span><code>fn parse_fn</code><span> are implemented as methods on the </span><code>Parser</code><span> struct.</span>
<span>I prefer to separate the two and to use free functions for the latter category, as the code is a bit more readable that way.</span></p>
<p><span>Let</span>&rsquo;<span>s start with parsing the top level.</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">use</span> TokenKind::*;</span>
<span class="line"><span class="hl-keyword">use</span> TreeKind::*;</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// File = Fn*</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">file</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>(); <i class="callout" data-value="1"></i></span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">while</span> !p.<span class="hl-title function_ invoke__">eof</span>() { <i class="callout" data-value="2"></i></span>
<span class="line">    <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at</span>(FnKeyword) {</span>
<span class="line">      <span class="hl-title function_ invoke__">func</span>(p)</span>
<span class="line">    } <span class="hl-keyword">else</span> {</span>
<span class="line">      p.<span class="hl-title function_ invoke__">advance_with_error</span>(<span class="hl-string">&quot;expected a function&quot;</span>); <i class="callout" data-value="3"></i></span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, File);  <i class="callout" data-value="1"></i></span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<p><span>Wrap the whole thing into a </span><code>File</code><span> node.</span></p>
</li>
<li>
<p><span>Use the </span><code>while</code><span> loop to parse a file as a series of functions.</span>
<span>Importantly, the entirety of the file is parsed; we break out of the loop only when the eof is reached.</span></p>
</li>
<li>
<p><span>To not get stuck in this loop, it</span>&rsquo;<span>s crucial that every iteration consumes at least one token.</span>
<span>If the token is </span><code>fn</code><span>, we</span>&rsquo;<span>ll parse at least a part of a function.</span>
<span>Otherwise, we consume the token and wrap it into an error node.</span></p>
</li>
</ol>
<p><span>Lets parse functions now:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// Fn = &#x27;fn&#x27; &#x27;name&#x27; ParamList (&#x27;-&gt;&#x27; TypeExpr)? Block</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">func</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(FnKeyword)); <i class="callout" data-value="1"></i></span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>(); <i class="callout" data-value="2"></i></span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(FnKeyword);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Name);</span>
<span class="line">  <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at</span>(LParen) { <i class="callout" data-value="3"></i></span>
<span class="line">    <span class="hl-title function_ invoke__">param_list</span>(p);</span>
<span class="line">  }</span>
<span class="line">  <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">eat</span>(Arrow) {</span>
<span class="line">    <span class="hl-title function_ invoke__">type_expr</span>(p);</span>
<span class="line">  }</span>
<span class="line">  <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at</span>(LCurly) { <i class="callout" data-value="3"></i></span>
<span class="line">    <span class="hl-title function_ invoke__">block</span>(p);</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, <span class="hl-built_in">Fn</span>); <i class="callout" data-value="2"></i></span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<p><span>When parsing a function, we assert that the current token is </span><code>fn</code><span>.</span>
<span>There</span>&rsquo;<span>s some duplication with the </span><span class="display"><code>if p.at(FnKeyword)</code><span> ,</span></span><span> check at the call-site, but this duplication actually helps readability.</span></p>
</li>
<li>
<p><span>Again, we surround the body of the function with </span><code>open</code><span>/</span><code>close</code><span> pair.</span></p>
</li>
<li>
<p><span>Although parameter list and function body are mandatory, we precede them with an </span><code>at</code><span> check.</span>
<span>We can still report the syntax error by analyzing the structure of the syntax tree (or we can report it as a side effect of parsing in the </span><code>else</code><span> branch if we want).</span>
<span>It wouldn</span>&rsquo;<span>t be wrong to just remove the </span><code>if</code><span> altogether and try to parse </span><code>param_list</code><span> unconditionally, but the </span><code>if</code><span> helps with reducing cascading errors.</span></p>
</li>
</ol>
<p><span>Now, the list of parameters:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// ParamList = &#x27;(&#x27; Param* &#x27;)&#x27;</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">param_list</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(LParen));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(LParen); <i class="callout" data-value="1"></i></span>
<span class="line">  <span class="hl-keyword">while</span> !p.<span class="hl-title function_ invoke__">at</span>(RParen) &amp;&amp; !p.<span class="hl-title function_ invoke__">eof</span>() { <i class="callout" data-value="2"></i></span>
<span class="line">    <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at</span>(Name) { <i class="callout" data-value="3"></i></span>
<span class="line">      <span class="hl-title function_ invoke__">param</span>(p);</span>
<span class="line">    } <span class="hl-keyword">else</span> {</span>
<span class="line">      <span class="hl-keyword">break</span>; <i class="callout" data-value="3"></i></span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(RParen); <i class="callout" data-value="1"></i></span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, ParamList);</span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<span>Inside, we have a standard code shape for parsing a bracketed list.</span>
<span>It can be extracted into a high-order function, but typing out the code manually is not a problem either.</span>
<span>This bit of code starts and ends with consuming the corresponding parenthesis.</span>
</li>
<li>
<span>In the happy case, we loop until the closing parenthesis.</span>
<span>However, it could also be the case that there</span>&rsquo;<span>s no closing parenthesis at all, so we add an </span><code>eof</code><span> condition as well.</span>
<span>Generally, every loop we write would have </span><code>&amp;&amp; !p.eof()</code><span> tackled on.</span>
</li>
<li>
<span>As with any loop, we need to ensure that each iteration consumes at least one token to not get stuck.</span>
<span>If the current token is an identifier, everything is ok, as we</span>&rsquo;<span>ll parse at least some part of the parameter.</span>
</li>
</ol>
<p><span>Parsing parameter is almost nothing new at this point:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// Param = &#x27;name&#x27; &#x27;:&#x27; TypeExpr &#x27;,&#x27;?</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">param</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(Name));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Name);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Colon);</span>
<span class="line">  <span class="hl-title function_ invoke__">type_expr</span>(p);</span>
<span class="line">  <span class="hl-keyword">if</span> !p.<span class="hl-title function_ invoke__">at</span>(RParen) { <i class="callout" data-value="1"></i></span>
<span class="line">    p.<span class="hl-title function_ invoke__">expect</span>(Comma);</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, Param);</span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<span>This is the only interesting bit.</span>
<span>To parse a comma-separated list of parameters with a trailing comma, it</span>&rsquo;<span>s enough to check if the following token after parameter is </span><code>)</code><span>.</span>
<span>This correctly handles all three cases:</span>
<ul>
<li>
<span>if the next token is </span><code>)</code><span>, we are at the end of the list, and no comma is required;</span>
</li>
<li>
<span>if the next token is </span><code>,</code><span>, we correctly advance past it;</span>
</li>
<li>
<span>finally, if the next token is anything else, then it</span>&rsquo;<span>s not a </span><code>)</code><span>, so we are not at the last element of the list and correctly emit an error.</span>
</li>
</ul>
</li>
</ol>
<p><span>Parsing types is trivial:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// TypeExpr = &#x27;name&#x27;</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">type_expr</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Name);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, TypeExpr);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>The notable aspect here is naming.</span>
<span>The production is deliberately named </span><code>TypeExpr</code><span>, rather than </span><code>Type</code><span>, to avoid confusion down the line.</span>
<span>Consider </span><span class="display"><code>fib(92)</code><span> .</span></span>
<span>It is an </span><em><span>expression</span></em><span>, which evaluates to a </span><em><span>value</span></em><span>.</span>
<span>The same thing happens with types.</span>
<span>For example, </span><span class="display"><code>Foo&lt;Int&gt;</code></span><span> is not a type yet, it</span>&rsquo;<span>s an expression which can be </span>&ldquo;<span>evaluated</span>&rdquo;<span> (at compile time) to a type (if </span><code>Foo</code><span> is a type alias, the result might be something like </span><code>Pair&lt;Int, Int&gt;</code><span>).</span></p>
<p><span>Parsing a block gets a bit more involved:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// Block = &#x27;{&#x27; Stmt* &#x27;}&#x27;</span></span>
<span class="line"><span class="hl-comment">//</span></span>
<span class="line"><span class="hl-comment">// Stmt =</span></span>
<span class="line"><span class="hl-comment">//   StmtLet</span></span>
<span class="line"><span class="hl-comment">// | StmtReturn</span></span>
<span class="line"><span class="hl-comment">// | StmtExpr</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">block</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(LCurly));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(LCurly);</span>
<span class="line">  <span class="hl-keyword">while</span> !p.<span class="hl-title function_ invoke__">at</span>(RCurly) &amp;&amp; !p.<span class="hl-title function_ invoke__">eof</span>() {</span>
<span class="line">    <span class="hl-keyword">match</span> p.<span class="hl-title function_ invoke__">nth</span>(<span class="hl-number">0</span>) {</span>
<span class="line">      LetKeyword =&gt; <span class="hl-title function_ invoke__">stmt_let</span>(p),</span>
<span class="line">      ReturnKeyword =&gt; <span class="hl-title function_ invoke__">stmt_return</span>(p),</span>
<span class="line">      _ =&gt; <span class="hl-title function_ invoke__">stmt_expr</span>(p),</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(RCurly);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, Block);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Block can contain many different kinds of statements, so we branch on the first token in the loop</span>&rsquo;<span>s body.</span>
<span>As usual, we need to maintain an invariant that the body consumes at least one token.</span>
<span>For </span><code>let</code><span> and </span><code>return</code><span> statements that</span>&rsquo;<span>s easy, they consume the fixed first token.</span>
<span>For the expression statement (things like </span><code>1 + 1;</code><span>) it gets more interesting, as an expression can start with many different tokens.</span>
<span>For the time being, we</span>&rsquo;<span>ll just kick the can down the road and require </span><code>stmt_expr</code><span> to deal with it (that is, to guarantee that at least one token is consumed).</span></p>
<p><span>Statements themselves are straightforward:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">// StmtLet = &#x27;let&#x27; &#x27;name&#x27; &#x27;=&#x27; Expr &#x27;;&#x27;</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">stmt_let</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(LetKeyword));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(LetKeyword);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Name);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(<span class="hl-built_in">Eq</span>);</span>
<span class="line">  <span class="hl-title function_ invoke__">expr</span>(p);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Semi);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, StmtLet);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// StmtReturn = &#x27;return&#x27; Expr &#x27;;&#x27;</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">stmt_return</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(ReturnKeyword));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(ReturnKeyword);</span>
<span class="line">  <span class="hl-title function_ invoke__">expr</span>(p);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Semi);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, StmtReturn);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// StmtExpr = Expr &#x27;;&#x27;</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">stmt_expr</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  <span class="hl-title function_ invoke__">expr</span>(p);</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(Semi);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, StmtExpr);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Again, for </span><code>stmt_expr</code><span>, we push </span>&ldquo;<span>must consume a token</span>&rdquo;<span> invariant onto </span><code>expr</code><span>.</span></p>
<p><span>Expressions are tricky.</span>
<span>They always are.</span>
<span>For starters, let</span>&rsquo;<span>s handle just the clearly-delimited cases, like literals and parenthesis:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-title function_ invoke__">expr_delimited</span>(p)</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr_delimited</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line">  <span class="hl-keyword">match</span> p.<span class="hl-title function_ invoke__">nth</span>(<span class="hl-number">0</span>) {</span>
<span class="line">    <span class="hl-comment">// ExprLiteral = &#x27;int&#x27; | &#x27;true&#x27; | &#x27;false&#x27;</span></span>
<span class="line">    Int | TrueKeyword | FalseKeyword =&gt; {</span>
<span class="line">      p.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">      p.<span class="hl-title function_ invoke__">close</span>(m, ExprLiteral)</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hl-comment">// ExprName = &#x27;name&#x27;</span></span>
<span class="line">    Name =&gt; {</span>
<span class="line">      p.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">      p.<span class="hl-title function_ invoke__">close</span>(m, ExprName)</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hl-comment">// ExprParen   = &#x27;(&#x27; Expr &#x27;)&#x27;</span></span>
<span class="line">    LParen =&gt; {</span>
<span class="line">      p.<span class="hl-title function_ invoke__">expect</span>(LParen);</span>
<span class="line">      <span class="hl-title function_ invoke__">expr</span>(p);</span>
<span class="line">      p.<span class="hl-title function_ invoke__">expect</span>(RParen);</span>
<span class="line">      p.<span class="hl-title function_ invoke__">close</span>(m, ExprParen)</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    _ =&gt; {</span>
<span class="line">      <span class="hl-keyword">if</span> !p.<span class="hl-title function_ invoke__">eof</span>() {</span>
<span class="line">        p.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">      }</span>
<span class="line">      p.<span class="hl-title function_ invoke__">close</span>(m, ErrorTree)</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>In the catch-all arm, we take care to consume the token, to make sure that the statement loop in </span><code>block</code><span> can always make progress.</span></p>
<p><span>Next expression to handle would be </span><code>ExprCall</code><span>.</span>
<span>This requires some preparation.</span>
<span>Consider this example: </span><span class="display"><code>f(1)(2)</code><span> .</span></span></p>
<p><span>We want the following parenthesis structure here:</span></p>

<figure class="code-block">


<pre><code><span class="line">+-ExprCall</span>
<span class="line">|</span>
<span class="line">|   +-ExprName</span>
<span class="line">|   |       +-ArgList</span>
<span class="line">|   |       |</span>
<span class="line">[ [ [f](1) ](2) ]</span>
<span class="line">  |    |</span>
<span class="line">  |    +-ArgList</span>
<span class="line">  |</span>
<span class="line">  +-ExprCall</span></code></pre>

</figure>
<p><span>The problem is, when the parser is at </span><code>f</code><span>, it doesn</span>&rsquo;<span>t yet know how many </span><code>Open</code><span> events it should emit.</span></p>
<p><span>We solve the problem by adding an API to go back and inject a new </span><code>Open</code><span> event into the middle of existing events.</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">MarkOpened</span> {</span>
<span class="line">  index: <span class="hl-type">usize</span>,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">MarkClosed</span> {</span>
<span class="line">  index: <span class="hl-type">usize</span>,</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">impl</span> <span class="hl-title class_">Parser</span> {</span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">open</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> MarkOpened {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">mark</span> = MarkOpened { index: <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">len</span>() };</span>
<span class="line">    <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">push</span>(Event::Open { kind: TreeKind::ErrorTree });</span>
<span class="line">    mark</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">close</span>(</span>
<span class="line">    &amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>,</span>
<span class="line">    m: MarkOpened,</span>
<span class="line">    kind: TreeKind,</span>
<span class="line">  ) <span class="hl-punctuation">-&gt;</span> MarkClosed { <i class="callout" data-value="1"></i></span>
<span class="line">    <span class="hl-keyword">self</span>.events[m.index] = Event::Open { kind };</span>
<span class="line">    <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">push</span>(Event::Close);</span>
<span class="line">    MarkClosed { index: m.index }</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">open_before</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>, m: MarkClosed) <span class="hl-punctuation">-&gt;</span> MarkOpened { <i class="callout" data-value="2"></i></span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">mark</span> = MarkOpened { index: m.index };</span>
<span class="line">    <span class="hl-keyword">self</span>.events.<span class="hl-title function_ invoke__">insert</span>(</span>
<span class="line">      m.index,</span>
<span class="line">      Event::Open { kind: TreeKind::ErrorTree },</span>
<span class="line">    );</span>
<span class="line">    mark</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<p><span>Here we adjust </span><code>close</code><span> to also return a </span><code>MarkClosed</code><span>, such that we can go back and add a new event before it.</span></p>
</li>
<li>
<p><span>The new API. It is like </span><code>open</code><span>, but also takes a </span><code>MarkClosed</code><span> which carries an index of an </span><code>Open</code><span> event in front of which we are to inject a new </span><code>Open</code><span>.</span>
<span>In the current implementation, for simplicity, we just inject into the middle of the vector, which is an O(N) operation worst-case.</span>
<span>A proper solution here would be to use an index-based linked list.</span>
<span>That is, </span><code>open_before</code><span> can push the new open event to the end of the list, and also mark the old event with a pointer to the freshly inserted one.</span>
<span>To store a pointer, an extra field is needed:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">Event</span> {</span>
<span class="line">  Open {</span>
<span class="line">    kind: TreeKind,</span>
<span class="line">    <span class="hl-comment">// Points forward into a list at the Open event</span></span>
<span class="line">    <span class="hl-comment">// which logically happens before this one.</span></span>
<span class="line">    open_before: <span class="hl-type">Option</span>&lt;<span class="hl-type">usize</span>&gt;,</span>
<span class="line">  },</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>The loop in </span><code>build_tree</code><span> needs to follow the </span><code>open_before</code><span> links.</span></p>
</li>
</ol>
<p><span>With this new API, we can parse function calls:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr_delimited</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) <span class="hl-punctuation">-&gt;</span> MarkClosed { <i class="callout" data-value="1"></i></span>
<span class="line">  ...</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">lhs</span> = <span class="hl-title function_ invoke__">expr_delimited</span>(p); <i class="callout" data-value="1"></i></span>
<span class="line"></span>
<span class="line">  <span class="hl-comment">// ExprCall = Expr ArgList</span></span>
<span class="line">  <span class="hl-keyword">while</span> p.<span class="hl-title function_ invoke__">at</span>(LParen) { <i class="callout" data-value="2"></i></span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open_before</span>(lhs);</span>
<span class="line">    <span class="hl-title function_ invoke__">arg_list</span>(p);</span>
<span class="line">    lhs = p.<span class="hl-title function_ invoke__">close</span>(m, ExprCall);</span>
<span class="line">  }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// ArgList = &#x27;(&#x27; Arg* &#x27;)&#x27;</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">arg_list</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(LParen));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(LParen);</span>
<span class="line">  <span class="hl-keyword">while</span> !p.<span class="hl-title function_ invoke__">at</span>(RParen) &amp;&amp; !p.<span class="hl-title function_ invoke__">eof</span>() { <i class="callout" data-value="3"></i></span>
<span class="line">    <span class="hl-title function_ invoke__">arg</span>(p);</span>
<span class="line">  }</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(RParen);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, ArgList);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-comment">// Arg = Expr &#x27;,&#x27;?</span></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">arg</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  <span class="hl-title function_ invoke__">expr</span>(p);</span>
<span class="line">  <span class="hl-keyword">if</span> !p.<span class="hl-title function_ invoke__">at</span>(RParen) { <i class="callout" data-value="4"></i></span>
<span class="line">    p.<span class="hl-title function_ invoke__">expect</span>(Comma);</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, Arg);</span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<p><code>expr_delimited</code><span> now returns a </span><code>MarkClosed</code><span> rather than </span><code>()</code><span>.</span>
<span>No code changes are required for this, as </span><code>close</code><span> calls are already in the tail position.</span></p>
</li>
<li>
<p><span>To parse function calls, we check whether we are at </span><code>(</code><span> and use </span><code>open_before</code><span> API if that is the case.</span></p>
</li>
<li>
<p><span>Parsing argument list should be routine by now.</span>
<span>Again, as an expression can start with many different tokens, we don</span>&rsquo;<span>t add an </span><code>if p.at</code><span> check to the loop</span>&rsquo;<span>s body, and require </span><code>arg</code><span> to consume at least one token.</span></p>
</li>
<li>
<p><span>Inside </span><code>arg</code><span>, we use an already familiar construct to parse an optionally trailing comma.</span></p>
</li>
</ol>
<p><span>Now only binary expressions are left.</span>
<span>We will use a Pratt parser for those.</span>
<span>This is genuinely tricky code, so I have a dedicated article explaining how it all works:</span></p>
<p><span class="display"><a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html"><em><span>Simple but Powerful Pratt Parsing</span></em></a><span> .</span></span></p>
<p><span>Here, I</span>&rsquo;<span>ll just dump a pageful of code without much explanation:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-title function_ invoke__">expr_rec</span>(p, Eof); <i class="callout" data-value="2"></i></span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr_rec</span>(p: &amp;<span class="hl-keyword">mut</span> Parser, left: TokenKind) { <i class="callout" data-value="1"></i></span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">lhs</span> = <span class="hl-title function_ invoke__">expr_delimited</span>(p);</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">while</span> p.<span class="hl-title function_ invoke__">at</span>(LParen) {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open_before</span>(lhs);</span>
<span class="line">    <span class="hl-title function_ invoke__">arg_list</span>(p);</span>
<span class="line">    lhs = p.<span class="hl-title function_ invoke__">close</span>(m, ExprCall);</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">loop</span> {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">right</span> = p.<span class="hl-title function_ invoke__">nth</span>(<span class="hl-number">0</span>);</span>
<span class="line">    <span class="hl-keyword">if</span> <span class="hl-title function_ invoke__">right_binds_tighter</span>(left, right) { <i class="callout" data-value="1"></i></span>
<span class="line">      <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open_before</span>(lhs);</span>
<span class="line">      p.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">      <span class="hl-title function_ invoke__">expr_rec</span>(p, right);</span>
<span class="line">      lhs = p.<span class="hl-title function_ invoke__">close</span>(m, ExprBinary);</span>
<span class="line">    } <span class="hl-keyword">else</span> {</span>
<span class="line">      <span class="hl-keyword">break</span>;</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">right_binds_tighter</span>( <i class="callout" data-value="1"></i></span>
<span class="line">  left: TokenKind,</span>
<span class="line">  right: TokenKind,</span>
<span class="line">) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">bool</span> {</span>
<span class="line">  <span class="hl-keyword">fn</span> <span class="hl-title function_">tightness</span>(kind: TokenKind) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">Option</span>&lt;<span class="hl-type">usize</span>&gt; {</span>
<span class="line">    [</span>
<span class="line">      <span class="hl-comment">// Precedence table:</span></span>
<span class="line">      [Plus, Minus].<span class="hl-title function_ invoke__">as_slice</span>(),</span>
<span class="line">      &amp;[Star, Slash],</span>
<span class="line">    ]</span>
<span class="line">    .<span class="hl-title function_ invoke__">iter</span>()</span>
<span class="line">    .<span class="hl-title function_ invoke__">position</span>(|level| level.<span class="hl-title function_ invoke__">contains</span>(&amp;kind))</span>
<span class="line">  }</span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(right_tightness) = <span class="hl-title function_ invoke__">tightness</span>(right) <span class="hl-keyword">else</span> { <i class="callout" data-value="3"></i></span>
<span class="line">    <span class="hl-keyword">return</span> <span class="hl-literal">false</span></span>
<span class="line">  };</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(left_tightness) = <span class="hl-title function_ invoke__">tightness</span>(left) <span class="hl-keyword">else</span> {</span>
<span class="line">    <span class="hl-built_in">assert!</span>(left == Eof);</span>
<span class="line">    <span class="hl-keyword">return</span> <span class="hl-literal">true</span>;</span>
<span class="line">  };</span>
<span class="line"></span>
<span class="line">  right_tightness &gt; left_tightness</span>
<span class="line">}</span></code></pre>

</figure>
<ol class="callout">
<li>
<p><span>In this version of pratt, rather than passing numerical precedence, I pass the actual token (learned that from </span><a href="https://www.scattered-thoughts.net/writing/better-operator-precedence/"><span>jamii</span>&rsquo;<span>s post</span></a><span>).</span>
<span>So, to determine whether to break or recur in the Pratt loop, we ask which of the two tokens binds tighter and act accordingly.</span></p>
</li>
<li>
<p><span>When we start parsing an expression, we don</span>&rsquo;<span>t have an operator to the left yet, so I just pass </span><code>Eof</code><span> as a dummy token.</span></p>
</li>
<li>
<p><span>The code naturally handles the case when the next token is not an operator (that is, when expression is complete, or when there</span>&rsquo;<span>s some syntax error).</span></p>
</li>
</ol>
<p><span>And that</span>&rsquo;<span>s it! We have parsed the entirety of L!</span></p>
</section>
<section id="Basic-Resilience">

    <h2>
    <a href="#Basic-Resilience"><span>Basic Resilience</span> </a>
    </h2>
<p><span>Let</span>&rsquo;<span>s see how resilient our basic parser is.</span>
<span>Let</span>&rsquo;<span>s check our motivational example:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">fib_rec</span>(f1: <span class="hl-type">u32</span>,</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">fib</span>(n: <span class="hl-type">u32</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">u32</span> {</span>
<span class="line">  <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">fib_rec</span>(<span class="hl-number">1</span>, <span class="hl-number">1</span>, n);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Here, the syntax tree our parser produces is surprisingly exactly what we want:</span></p>

<figure class="code-block">


<pre><code><span class="line">File</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;fib_rec&#x27;</span></span>
<span class="line">    ParamList</span>
<span class="line">      <span class="hl-string">&#x27;(&#x27;</span></span>
<span class="line">      (Param <span class="hl-string">&#x27;f1&#x27;</span> <span class="hl-string">&#x27;:&#x27;</span> (TypeExpr <span class="hl-string">&#x27;u32&#x27;</span>) <span class="hl-string">&#x27;,&#x27;</span>)</span>
<span class="line">    error: expected RParen</span>
<span class="line"></span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;fib&#x27;</span></span>
<span class="line">    ...</span></code></pre>

</figure>
<p><span>For the first incomplete function, we get </span><code>Fn</code><span>, </span><code>Param</code><span> and </span><code>ParamList</code><span>, as we should.</span>
<span>The second function is parsed without any errors.</span></p>
<p><span>Curiously, we get this great result without much explicit effort to make parsing resilient, it</span>&rsquo;<span>s a natural outcome of just not failing in the presence of errors.</span>
<span>The following ingredients help us:</span></p>
<ul>
<li>
<span>homogeneous syntax tree supports arbitrary malformed code,</span>
</li>
<li>
<span>any syntactic construct is parsed left-to-right, and valid prefixes are always recognized,</span>
</li>
<li>
<span>our top-level loop in </span><code>file</code><span> is greedy: it either parses a function, or skips a single token and tries to parse a function again.</span>
<span>That way, if there</span>&rsquo;<span>s a valid function somewhere, it will be recognized.</span>
</li>
</ul>
<p><span>Thinking about the last case both reveals the limitations of our current code, and shows avenues for improvement.</span>
<span>In general, parsing works as a series of nested loops:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">loop</span> { <span class="hl-comment">// parse a list of functions</span></span>
<span class="line"></span>
<span class="line">  <span class="hl-keyword">loop</span> { <span class="hl-comment">// parse a list of statements inside a function</span></span>
<span class="line"></span>
<span class="line">    <span class="hl-keyword">loop</span> { <span class="hl-comment">// parse a list of expressions</span></span>
<span class="line"></span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>If something goes wrong inside a loop, our choices are:</span></p>
<ul>
<li>
<span>skip a token, and continue with the next iteration of the current loop,</span>
</li>
<li>
<span>break out of the inner loop, and let the outer loop handle recovery.</span>
</li>
</ul>
<p><span>The top-most loop must use the </span>&ldquo;<span>skip a token</span>&rdquo;<span> solution, because it needs to consume all of the input tokens.</span></p>
</section>
<section id="Improving-Resilience">

    <h2>
    <a href="#Improving-Resilience"><span>Improving Resilience</span> </a>
    </h2>
<p><span>Right now, each loop either always skips, or always breaks.</span>
<span>This is not optimal.</span>
<span>Consider this example:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">f1</span>(x: <span class="hl-type">i32</span>,</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">f2</span>(x: <span class="hl-type">i32</span>,, z: <span class="hl-type">i32</span>) {}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">f3</span>() {}</span></code></pre>

</figure>
<p><span>Here, for </span><code>f1</code><span> we want to break out of </span><code>param_list</code><span> loop, and our code does just that.</span>
<span>For </span><code>f2</code><span> though, the error is a duplicated comma (the user will add a new parameter between </span><code>x</code><span> and </span><code>z</code><span> shortly), so we want to skip here.</span>
<span>We don</span>&rsquo;<span>t, and, as a result, the syntax tree for </span><code>f2</code><span> is a train wreck:</span></p>

<figure class="code-block">


<pre><code><span class="line">Fn</span>
<span class="line">  <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">  <span class="hl-string">&#x27;f2&#x27;</span></span>
<span class="line">  ParamList</span>
<span class="line">    <span class="hl-string">&#x27;(&#x27;</span></span>
<span class="line">    (Param <span class="hl-string">&#x27;x&#x27;</span> <span class="hl-string">&#x27;:&#x27;</span> (TypeExpr <span class="hl-string">&#x27;i32&#x27;</span>) <span class="hl-string">&#x27;,&#x27;</span>)</span>
<span class="line">(ErrorTree <span class="hl-string">&#x27;,&#x27;</span>)</span>
<span class="line">(ErrorTree <span class="hl-string">&#x27;z&#x27;</span>)</span>
<span class="line">(ErrorTree <span class="hl-string">&#x27;:&#x27;</span>)</span>
<span class="line">(ErrorTree <span class="hl-string">&#x27;i32&#x27;</span>)</span>
<span class="line">(ErrorTree <span class="hl-string">&#x27;)&#x27;</span>)</span>
<span class="line">(ErrorTree <span class="hl-string">&#x27;{&#x27;</span>)</span>
<span class="line">(ErrorTree <span class="hl-string">&#x27;}&#x27;</span>)</span></code></pre>

</figure>
<p><span>For parameters, it is reasonable to skip tokens until we see something which implies the end of the parameter list.</span>
<span>For example, if we are parsing a list of parameters and see an </span><code>fn</code><span> token, then we</span>&rsquo;<span>d better stop.</span>
<span>If we see some less salient token, it</span>&rsquo;<span>s better to gobble it up.</span>
<span>Let</span>&rsquo;<span>s implement the idea:</span></p>

<figure class="code-block">


<pre><code><span class="line hl-line"><span class="hl-keyword">const</span> PARAM_LIST_RECOVERY: &amp;[TokenKind] = &amp;[Arrow, LCurly, FnKeyword];</span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">param_list</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(LParen));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(LParen);</span>
<span class="line">  <span class="hl-keyword">while</span> !p.<span class="hl-title function_ invoke__">at</span>(RParen) &amp;&amp; !p.<span class="hl-title function_ invoke__">eof</span>() {</span>
<span class="line">    <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at</span>(Name) {</span>
<span class="line">      <span class="hl-title function_ invoke__">param</span>(p);</span>
<span class="line">    } <span class="hl-keyword">else</span> {</span>
<span class="line hl-line">      <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at_any</span>(PARAM_LIST_RECOVERY) {</span>
<span class="line hl-line">        <span class="hl-keyword">break</span>;</span>
<span class="line hl-line">      }</span>
<span class="line hl-line">      p.<span class="hl-title function_ invoke__">advance_with_error</span>(<span class="hl-string">&quot;expected parameter&quot;</span>);</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(RParen);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, ParamList);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>Here, we use </span><code>at_any</code><span> helper function, which is like </span><code>at</code><span>, but takes a list of tokens.</span>
<span>The real implementation would use bitsets for this purpose.</span></p>
<p><span>The example now parses correctly:</span></p>

<figure class="code-block">


<pre><code><span class="line">File</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;f1&#x27;</span></span>
<span class="line">    ParamList</span>
<span class="line">      <span class="hl-string">&#x27;(&#x27;</span></span>
<span class="line">      (Param <span class="hl-string">&#x27;x&#x27;</span> <span class="hl-string">&#x27;:&#x27;</span> (TypeExpr <span class="hl-string">&#x27;i32&#x27;</span>) <span class="hl-string">&#x27;,&#x27;</span>)</span>
<span class="line">      error: expected RParen</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;f2&#x27;</span></span>
<span class="line">    ParamList</span>
<span class="line">      <span class="hl-string">&#x27;(&#x27;</span></span>
<span class="line">      (Param <span class="hl-string">&#x27;x&#x27;</span> <span class="hl-string">&#x27;:&#x27;</span> (TypeExpr <span class="hl-string">&#x27;i32&#x27;</span>) <span class="hl-string">&#x27;,&#x27;</span>)</span>
<span class="line">      ErrorTree</span>
<span class="line">        error: expected parameter</span>
<span class="line">        <span class="hl-string">&#x27;,&#x27;</span></span>
<span class="line">      (Param <span class="hl-string">&#x27;z&#x27;</span> <span class="hl-string">&#x27;:&#x27;</span> (TypeExpr <span class="hl-string">&#x27;i32&#x27;</span>))</span>
<span class="line">      <span class="hl-string">&#x27;)&#x27;</span></span>
<span class="line">    (Block <span class="hl-string">&#x27;{&#x27;</span> <span class="hl-string">&#x27;}&#x27;</span>)</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;f3&#x27;</span></span>
<span class="line">    (ParamList <span class="hl-string">&#x27;(&#x27;</span> <span class="hl-string">&#x27;)&#x27;</span>)</span>
<span class="line">    (Block <span class="hl-string">&#x27;{&#x27;</span> <span class="hl-string">&#x27;}&#x27;</span>)</span></code></pre>

</figure>
<p><span>What is a reasonable </span><code>RECOVERY</code><span> set in a general case?</span>
<span>I don</span>&rsquo;<span>t know the answer to this question, but </span><dfn>follow</dfn><span> sets from formal grammar theory give a good intuition.</span>
<span>We don</span>&rsquo;<span>t want </span><em><span>exactly</span></em><span> the </span><dfn>follow</dfn><span> set: for </span><code>ParamList</code><span>, </span><code>{</code><span> is in </span><dfn>follow</dfn><span>, and we do want it to be a part of the recovery set, but </span><code>fn</code><span> is </span><em><span>not</span></em><span> in </span><dfn>follow</dfn><span>, and yet it is important to recover on it.</span>
<code>fn</code><span> is included because it</span>&rsquo;<span>s in the </span><dfn>follow</dfn><span> for </span><code>Fn</code><span>, and </span><code>ParamList</code><span> is a child of </span><code>Fn</code><span>: we also want to recursively include ancestor </span><dfn>follow</dfn><span> sets into the recovery set.</span></p>
<p><span>For expressions and statements, we have the opposite problem </span>&mdash;<span> </span><code>block</code><span> and </span><code>arg_list</code><span> loops eagerly consume erroneous tokens, but sometimes it would be wise to break out of the loop instead.</span></p>
<p><span>Consider this example:</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">f</span>() {</span>
<span class="line">  <span class="hl-title function_ invoke__">g</span>(<span class="hl-number">1</span>,</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">x</span> =</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">g</span>() {}</span></code></pre>

</figure>
<p><span>It gives another train wreck syntax tree, where the </span><code>g</code><span> function is completely missed:</span></p>

<figure class="code-block">


<pre><code><span class="line">File</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;f&#x27;</span></span>
<span class="line">    (ParamList <span class="hl-string">&#x27;(&#x27;</span> <span class="hl-string">&#x27;)&#x27;</span>)</span>
<span class="line">    Block</span>
<span class="line">      <span class="hl-string">&#x27;{&#x27;</span></span>
<span class="line">      StmtExpr</span>
<span class="line">        ExprCall</span>
<span class="line">          (ExprName <span class="hl-string">&#x27;g&#x27;</span>)</span>
<span class="line">          ArgList</span>
<span class="line">            <span class="hl-string">&#x27;(&#x27;</span></span>
<span class="line">            (Arg (ExprLiteral <span class="hl-string">&#x27;1&#x27;</span>) <span class="hl-string">&#x27;,&#x27;</span>)</span>
<span class="line">            (Arg (ErrorTree <span class="hl-string">&#x27;let&#x27;</span>))</span>
<span class="line">            (Arg (ExprName <span class="hl-string">&#x27;x&#x27;</span>))</span>
<span class="line">            (Arg (ErrorTree <span class="hl-string">&#x27;=&#x27;</span>))</span>
<span class="line">            (Arg (ErrorTree <span class="hl-string">&#x27;}&#x27;</span>))</span>
<span class="line">            (Arg (ErrorTree <span class="hl-string">&#x27;fn&#x27;</span>))</span>
<span class="line">            Arg</span>
<span class="line">              ExprCall</span>
<span class="line">                (ExprName <span class="hl-string">&#x27;g&#x27;</span>)</span>
<span class="line">                (ArgList <span class="hl-string">&#x27;(&#x27;</span> <span class="hl-string">&#x27;)&#x27;</span>)</span>
<span class="line">            (Arg (ErrorTree <span class="hl-string">&#x27;{&#x27;</span>))</span>
<span class="line">            (Arg (ErrorTree <span class="hl-string">&#x27;}&#x27;</span>))</span></code></pre>

</figure>
<p><span>Recall that the root cause here is that we require </span><code>expr</code><span> to consume at least one token, because it</span>&rsquo;<span>s not immediately obvious which tokens can start an expression.</span>
<span>It</span>&rsquo;<span>s not immediately obvious, but easy to compute </span>&mdash;<span> that</span>&rsquo;<span>s exactly </span><dfn>first</dfn><span> set from formal grammars.</span></p>
<p><span>Using it, we get:</span></p>

<figure class="code-block">


<pre><code><span class="line hl-line"><span class="hl-keyword">const</span> STMT_RECOVERY: &amp;[TokenKind] = &amp;[FnKeyword];</span>
<span class="line hl-line"><span class="hl-keyword">const</span> EXPR_FIRST: &amp;[TokenKind] =</span>
<span class="line hl-line">  &amp;[Int, TrueKeyword, FalseKeyword, Name, LParen];</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">block</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(LCurly));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(LCurly);</span>
<span class="line">  <span class="hl-keyword">while</span> !p.<span class="hl-title function_ invoke__">at</span>(RCurly) &amp;&amp; !p.<span class="hl-title function_ invoke__">eof</span>() {</span>
<span class="line">    <span class="hl-keyword">match</span> p.<span class="hl-title function_ invoke__">nth</span>(<span class="hl-number">0</span>) {</span>
<span class="line">      LetKeyword =&gt; <span class="hl-title function_ invoke__">stmt_let</span>(p),</span>
<span class="line">      ReturnKeyword =&gt; <span class="hl-title function_ invoke__">stmt_return</span>(p),</span>
<span class="line">      _ =&gt; {</span>
<span class="line hl-line">        <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at_any</span>(EXPR_FIRST) {</span>
<span class="line hl-line">          <span class="hl-title function_ invoke__">stmt_expr</span>(p)</span>
<span class="line hl-line">        } <span class="hl-keyword">else</span> {</span>
<span class="line hl-line">          <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at_any</span>(STMT_RECOVERY) {</span>
<span class="line hl-line">            <span class="hl-keyword">break</span>;</span>
<span class="line hl-line">          }</span>
<span class="line hl-line">          p.<span class="hl-title function_ invoke__">advance_with_error</span>(<span class="hl-string">&quot;expected statement&quot;</span>);</span>
<span class="line hl-line">        }</span>
<span class="line">      }</span>
<span class="line">    }</span>
<span class="line">  }</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(RCurly);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, Block);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">arg_list</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) {</span>
<span class="line">  <span class="hl-built_in">assert!</span>(p.<span class="hl-title function_ invoke__">at</span>(LParen));</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(LParen);</span>
<span class="line">  <span class="hl-keyword">while</span> !p.<span class="hl-title function_ invoke__">at</span>(RParen) &amp;&amp; !p.<span class="hl-title function_ invoke__">eof</span>() {</span>
<span class="line hl-line">    <span class="hl-keyword">if</span> p.<span class="hl-title function_ invoke__">at_any</span>(EXPR_FIRST) {</span>
<span class="line hl-line">      <span class="hl-title function_ invoke__">arg</span>(p);</span>
<span class="line hl-line">    } <span class="hl-keyword">else</span> {</span>
<span class="line hl-line">        <span class="hl-keyword">break</span>;</span>
<span class="line hl-line">    }</span>
<span class="line">  }</span>
<span class="line">  p.<span class="hl-title function_ invoke__">expect</span>(RParen);</span>
<span class="line"></span>
<span class="line">  p.<span class="hl-title function_ invoke__">close</span>(m, ArgList);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>This fixes the syntax tree:</span></p>

<figure class="code-block">


<pre><code><span class="line">File</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;f&#x27;</span></span>
<span class="line">    (ParamList <span class="hl-string">&#x27;(&#x27;</span> <span class="hl-string">&#x27;)&#x27;</span>)</span>
<span class="line">    Block</span>
<span class="line">      <span class="hl-string">&#x27;{&#x27;</span></span>
<span class="line">      StmtExpr</span>
<span class="line">        ExprCall</span>
<span class="line">          (ExprName <span class="hl-string">&#x27;g&#x27;</span>)</span>
<span class="line">          ArgList</span>
<span class="line">            <span class="hl-string">&#x27;(&#x27;</span></span>
<span class="line">            (Arg (ExprLiteral <span class="hl-string">&#x27;1&#x27;</span> <span class="hl-string">&#x27;,&#x27;</span>))</span>
<span class="line">      StmtLet</span>
<span class="line">        <span class="hl-string">&#x27;let&#x27;</span></span>
<span class="line">        <span class="hl-string">&#x27;x&#x27;</span></span>
<span class="line">        <span class="hl-string">&#x27;=&#x27;</span></span>
<span class="line">        (ErrorTree <span class="hl-string">&#x27;}&#x27;</span>)</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;g&#x27;</span></span>
<span class="line">    (ParamList <span class="hl-string">&#x27;(&#x27;</span> <span class="hl-string">&#x27;)&#x27;</span>)</span>
<span class="line">    (Block <span class="hl-string">&#x27;{&#x27;</span> <span class="hl-string">&#x27;}&#x27;</span>)</span></code></pre>

</figure>
<p><span>There</span>&rsquo;<span>s only one issue left.</span>
<span>Our </span><code>expr</code><span> parsing is still greedy, so, in a case like this</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">f</span>() {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">x</span> = <span class="hl-number">1</span> +</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">y</span> = <span class="hl-number">2</span></span>
<span class="line">}</span></code></pre>

</figure>
<p><span>the </span><code>let</code><span> will be consumed as a right-hand-side operand of </span><code>+</code><span>.</span>
<span>Now that the callers of </span><code>expr</code><span> contain a check for </span><code>EXPR_FIRST</code><span>, we no longer need this greediness and can return </span><code>None</code><span> if no expression can be parsed:</span></p>

<figure class="code-block">


<pre><code><span class="line hl-line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr_delimited</span>(p: &amp;<span class="hl-keyword">mut</span> Parser) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">Option</span>&lt;MarkClosed&gt; {</span>
<span class="line">  <span class="hl-keyword">let</span> <span class="hl-variable">result</span> = <span class="hl-keyword">match</span> p.<span class="hl-title function_ invoke__">nth</span>(<span class="hl-number">0</span>) {</span>
<span class="line">    <span class="hl-comment">// ExprLiteral = &#x27;int&#x27; | &#x27;true&#x27; | &#x27;false&#x27;</span></span>
<span class="line">    Int | TrueKeyword | FalseKeyword =&gt; {</span>
<span class="line">      <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line">      p.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">      p.<span class="hl-title function_ invoke__">close</span>(m, ExprLiteral)</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hl-comment">// ExprName = &#x27;name&#x27;</span></span>
<span class="line">    Name =&gt; {</span>
<span class="line">      <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line">      p.<span class="hl-title function_ invoke__">advance</span>();</span>
<span class="line">      p.<span class="hl-title function_ invoke__">close</span>(m, ExprName)</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hl-comment">// ExprParen   = &#x27;(&#x27; Expr &#x27;)&#x27;</span></span>
<span class="line">    LParen =&gt; {</span>
<span class="line">      <span class="hl-keyword">let</span> <span class="hl-variable">m</span> = p.<span class="hl-title function_ invoke__">open</span>();</span>
<span class="line">      p.<span class="hl-title function_ invoke__">expect</span>(LParen);</span>
<span class="line">      <span class="hl-title function_ invoke__">expr</span>(p);</span>
<span class="line">      p.<span class="hl-title function_ invoke__">expect</span>(RParen);</span>
<span class="line">      p.<span class="hl-title function_ invoke__">close</span>(m, ExprParen)</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    _ =&gt; {</span>
<span class="line hl-line">      <span class="hl-built_in">assert!</span>(!p.<span class="hl-title function_ invoke__">at_any</span>(EXPR_FIRST));</span>
<span class="line hl-line">      <span class="hl-keyword">return</span> <span class="hl-literal">None</span>;</span>
<span class="line">    }</span>
<span class="line">  };</span>
<span class="line">  <span class="hl-title function_ invoke__">Some</span>(result)</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">expr_rec</span>(p: &amp;<span class="hl-keyword">mut</span> Parser, left: TokenKind) {</span>
<span class="line hl-line">  <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(<span class="hl-keyword">mut</span> lhs) = <span class="hl-title function_ invoke__">expr_delimited</span>(p) <span class="hl-keyword">else</span> {</span>
<span class="line hl-line">    <span class="hl-keyword">return</span>;</span>
<span class="line hl-line">  };</span>
<span class="line">  ...</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>This gives the following syntax tree:</span></p>

<figure class="code-block">


<pre><code><span class="line">File</span>
<span class="line">  Fn</span>
<span class="line">    <span class="hl-string">&#x27;fn&#x27;</span></span>
<span class="line">    <span class="hl-string">&#x27;f&#x27;</span></span>
<span class="line">    (ParamList <span class="hl-string">&#x27;(&#x27;</span> <span class="hl-string">&#x27;)&#x27;</span>)</span>
<span class="line">    Block</span>
<span class="line">      <span class="hl-string">&#x27;{&#x27;</span></span>
<span class="line">      StmtLet</span>
<span class="line">        <span class="hl-string">&#x27;let&#x27;</span></span>
<span class="line">        <span class="hl-string">&#x27;x&#x27;</span></span>
<span class="line">        <span class="hl-string">&#x27;=&#x27;</span></span>
<span class="line">        (ExprBinary (ExprLiteral <span class="hl-string">&#x27;1&#x27;</span>) <span class="hl-string">&#x27;+&#x27;</span>)</span>
<span class="line">      StmtLet</span>
<span class="line">        <span class="hl-string">&#x27;let&#x27;</span></span>
<span class="line">        <span class="hl-string">&#x27;y&#x27;</span></span>
<span class="line">        <span class="hl-string">&#x27;=&#x27;</span></span>
<span class="line">        (ExprLiteral <span class="hl-string">&#x27;2&#x27;</span>)</span>
<span class="line">      <span class="hl-string">&#x27;}&#x27;</span></span></code></pre>

</figure>
<p><span>And this concludes the tutorial!</span>
<span>You are now capable of implementing an IDE-grade parser for a real programming language from scratch.</span></p>
<p><span>Summarizing:</span></p>
<ul>
<li>
<p><span>Resilient parsing means recovering as much syntactic structure from erroneous code as possible.</span></p>
</li>
<li>
<p><span>Resilient parsing is important for IDEs and language servers, who</span>&rsquo;<span>s job mostly ends when the code does not have errors any more.</span></p>
</li>
<li>
<p><span>Resilient parsing is related, but distinct from error recovery and repair.</span>
<span>Rather than guessing what the user meant to write, the parser tries to make sense of what is actually written.</span></p>
</li>
<li>
<p><span>Academic literature tends to focus on error repair, and mostly ignores pure resilience.</span></p>
</li>
<li>
<p><span>The biggest challenge of resilient parsing is the design of a syntax tree data structure.</span>
<span>It should provide convenient and type-safe access to well-formed syntax trees, while allowing arbitrary malformed trees.</span></p>
</li>
<li>
<p><span>One possible design here is to make the underlying tree a dynamically-typed data structure (like JSON), and layer typed accessors on top (not covered in this article).</span></p>
</li>
<li>
<p><span>LL style parsers are a good fit for resilient parsing.</span>
<span>Because code is written left-to-right, it</span>&rsquo;<span>s important that the parser recognizes well-formed prefixes of incomplete syntactic constructs, and LL does just that.</span></p>
</li>
<li>
<p><span>Ultimately, parsing works as a stack of nested </span><code>for</code><span> loops.</span>
<span>Inside a single </span><code>for</code><span> loop, on each iteration, we need to decide between:</span></p>
<ul>
<li>
<span>trying to parse a sequence element,</span>
</li>
<li>
<span>skipping over an unexpected token,</span>
</li>
<li>
<span>breaking out of the nested loop and delegating recovery to the parent loop.</span>
</li>
</ul>
</li>
<li>
<p><dfn>first</dfn><span>, </span><dfn>follow</dfn><span> and recovery sets help making a specific decision.</span></p>
</li>
<li>
<p><span>In any case, if a loop tries to parse an item, item parsing </span><em><span>must</span></em><span> consume at least one token (if only to report an error).</span></p>
</li>
</ul>
<script type="module" src="/assets/resilient-parsing/main.js"></script>
<p><span>Source code for the article is here: </span><span class="display"><a href="https://github.com/matklad/resilient-ll-parsing/blob/master/src/lib.rs#L44" class="url">https://github.com/matklad/resilient-ll-parsing/blob/master/src/lib.rs#L44</a><span> .</span></span></p>
</section>
]]></content>
</entry>

</feed>
